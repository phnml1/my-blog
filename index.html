<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/media/a15f2fce4b98b461-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/3d9ea938b6afa941-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/ee285b05ac47a625-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/1de9c871cd3a3669-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/bf54e24be5d8358f-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/02701f268eb7de16-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/55876d34f3407927.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/55876d34f3407927.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/4633ec6f7ca519e3.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/4633ec6f7ca519e3.css" crossorigin="" data-n-p=""/><link rel="preload" href="/_next/static/css/83110ef01d855e81.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/83110ef01d855e81.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-5b3d08c41a2bb2b6.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-66d32731bdd20e83.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-aa55ffd08992d156.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-e287481ee6e74633.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/135-0e45b9dfc77f7376.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/979-7390dd4fc9e19803.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/index-4585cc75c60696f1.js" defer="" crossorigin=""></script><script src="/_next/static/r3TVFGStx9-VzPRjNWTfb/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/r3TVFGStx9-VzPRjNWTfb/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"posts":[{"slug":"posts/React/[React DeepDive] React의 가상 DOM","title":"[React DeepDive] React의 가상 DOM","date":"2024-10-25T12:00:24.000Z","image":"React.svg","summary":"리액트 딥다이브 책 내용 중 '가상 DOM과 파이버'의 정리 내용입니다.","tags":["react","deepdive","Virtual DOM"],"content":"# [React DeepDive] React의 가상 DOM\r\n\r\n\r\n리액트의 특징 중 하나는 실제 DOM이 아닌 가상 DOM을 운영한다는 것이다. 이번 글에서는 React DeepDive에서 다루는 **가상 DOM이 무엇인지**, **그리고 실제 DOM에 대해 어떤 이점이 있는지 살펴보고**, 가상 DOM을 다룰 때 **주의할 점**에 대해서도 다루려고 한다.\r\n\r\n## DOM과 브라우저 렌더링 과정\r\n\u003e **DOM**: 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.\r\n\r\n브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정은 다음과 같다.\r\n\r\n\u003cimg src=\"트리를 그리는과정.png\" alt=\"트리를 그리는 과정\" width=\"800\" height=\"600\"/\u003e\r\n\r\n\r\n1. 브라우저가 사용자 요청한 주소에서 HTML파일을 다운로드한다.\r\n\r\n2. 브라우저의 렌더링 엔진이 HTML을 파싱해 DOM노드로 구성된 트리 즉, `DOM`을 만든다.\r\n3. 2번 과정에서 CSS파일을 만나면 해당 CSS 파일도 다운로드한다.\r\n4. 브라우저의 렌더링 엔진이 이 CSS역시 파싱해 CSS 노드로 구성된 트리 즉, `CSSOM`을 만든다\r\n5. 브라우저는 DOM 노드를 순회하는데 모든 노드가 아닌, **사용자 눈에 보이는 노드만**(display:none과 같은 노드는 방문 x) 방문한다.\r\n6. 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. \r\n\u003e\t-  `레이아웃`: 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정이며, 이 과정을 거치면 **페인팅 과정도 거치게 된다.**\r\n\u003e-  `페인팅`: 레이아웃 단계를 거친 노드의 색과 같은 **실제 유효한 모습을 그리는 과정**\r\n\r\n## 가상 DOM의 탄생 배경\r\n\r\n### 웹페이지를 추가로 렌더링 하는데 드는 비용\r\n앞에서 살펴본 브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다. \r\n\r\n또한 정보를 보여주는데 그치지 않고 사용자의 인터렉션을 통해 다양한 정보를 노출해야 하기에, 렌더링이 완료된 이후에도 **사용자의 인터렉션으로 웹페이지가 변경되는 상황** 또한 고려해야 한다.\r\n\r\n이 과정에서 예를 들어,\r\n- 특정 요소의 색상이 변경되는 경우: 페인팅만이 일어나서 빠른처리가 가능하다.\r\n\r\n- **특정 요소의 노출 여부나 사이즈가 변경되는 경우**: 레이아웃이 일어나고, 레이아웃은 **필연적으로 리페인팅을 발생**하기 때문에 더 많은 비용이 든다.\r\n\r\n- DOM 변경이 일어나는 요소가 **자식 요소를 많이 가지고 있는 경우**: 하위 자식 요소 역시 변경되야 해서 더 많은 비용 지불\r\n\r\n이러한 추가 렌더링 작업은 하나의 페이지에서 모든 작업이 일어나는 `싱글 페이지 애플리케이션(SPA)`에서 더 많아진다. \r\n\r\n페이지가 변경될 때 처음부터 HTML을 새로 받아서 다시금 렌더링 과정을 시작하는 일반적인 웹페이지와는 다르게, 하나의 페이지에서 계속해서 요소의 위치를 재계산하게 된다.\r\n\r\n그러므로 라우팅이 변경되는 경우 고정된 헤더와 같은 요소들을 제외하고 대부분의 요소를 삭제, 삽입 및 요소의 위치를 다시 계산해야 하므로, DOM을 관리하는 과정에서 부담하는 비용이 커진다.\r\n\r\n### 가상 DOM의 탄생\r\n사용자의 인터렉션에 따라 DOM의 모든 변경 사항을 추적하는 것은 개발자에게는 너무나 수고스러운 일이다.  그렇기에 모든 DOM의 변경보다 **결과적으로 만들어지는 DOM 결과물 하나만 아는 것**이 개발자의 입장에서 더 유용할 것이다.\r\n\r\n이것을 해결하기 위해 탄생한 것이 바로 `가상 DOM`이다.  \r\n가상 DOM은 실제 브라우저가 아닌 리액트가 관리하는 가상의 DOM을 의미한다.\r\n\r\n가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 **메모리에 저장**하고, 리액트가 실제 변경에 대한 준비가 완료되었을 때, 실제 브라우저의 DOM에 반영한다.\r\n\r\n이렇게 DOM 계산을 메모리에서 계산하는 과정을 한 번 거치게 된다면 실제로는 여러 번 발생했을 렌더링 과정을 최소화하여 부담을 덜 수 있다.\r\n\r\n\u003e 가상 DOM은 **일반적인 브라우저보다 무조건 항상 빠르지는 않다**. \r\n\u003e\r\n\u003e 무조건 빠른 것이 아닌, 대부분의 상황에서 웬만한 애플리케이션을 만들 정도로 충분히 빠르다고 보는 것이 옳다.\r\n\r\n## 가상 DOM을 위한 아키텍처, 리액트 파이버\r\n가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 `리액트 파이버`이다.\r\n\r\n`리액트 파이버`는 리액트에서 관리하는 평범한 자바스크립트 객체이다. \r\n`파이버`는 `파이버 재조정자(fiber reconciler)`가 관리하는데, 가상 DOM과 실제 DOM을 비교하여 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.\r\n\r\n\u003e 재조정(reconcilation): 리액트에서 어떤 부분을 새로 렌더링 해야하는지 가상 DOM과 실제 DOM을 비교하는 과정 \r\n\r\n파이버는 애니메이션,레이아웃,사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하며, 다음과 같은 일을 할 수 있다.\r\n-  작업을 작은 단위로 쪼개고  **우선순위를  매긴다.**\r\n\r\n-  이 작업들은 일시 정지 및 다시 시작이 가능하다.\r\n\r\n- 이전 작업을 재사용 하거나 필요 없는 경우에는 폐기할 수 있다.\r\n\r\n이러한 모든 과정은 **비동기로 일어난다**. 과거에는 이러한 조정 알고리즘이 동기적인 스택 알고리즘으로 이뤄져 있었고, 동기적으로 작업이 이뤄졌기에 자바스크립트의 싱글 스레드의 특징 상 수행 중인 작업은 중단될 수 없었다. \r\n이러한 문제 때문에 리액트 팀은 스택 조정자 대신 파이버라는 개념을 탄생시킨다.\r\n\r\n### 파이버는 어떻게 구현되어 있을까?\r\n`파이버`는 일단 하나의 작업 단위로 구성되어 있다. 리액트는 작업 단위를 하나씩 처리하고, **finishWork( )** 라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다. \r\n이러한 단계는 두 단계로 나뉘는데,\r\n- `렌더 단계`: 사용자에게 노출되지 않는 모든 **비동기** 작업을 수행하고, **우선 순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.**\r\n- `커밋 단계`: DOM에 실제 변경 사항을 반영하기 위한 작업, commitWork( )가 실행되는데, **동기식**으로 일어나고 중단될 수 없다.\r\n\r\n파이버는 실제 리액트 코드에서 이렇게 구현되어 있다.\r\n```js\r\nfunction FiberNode(tag, pendingProps, key, mode) {\r\n  // Instance\r\n  this.tag = tag;\r\n  this.key = key;\r\n  this.elementType = null;\r\n  this.type = null;\r\n  this.stateNode = null;\r\n\r\n  // Fiber\r\n  this.return = null;\r\n  this.child = null;\r\n  this.sibling = null;\r\n  this.index = 0;\r\n\r\n  this.ref = null;\r\n\r\n  this.pendingProps = pendingProps;\r\n  this.memoizedProps = null;\r\n  this.updateQueue = null;\r\n  this.memoizedState = null;\r\n  this.dependencies = null;\r\n\r\n  this.mode = mode;\r\n\r\n  // Effects\r\n  this.effectTag = NoEffect;\r\n  this.nextEffect = null;\r\n\r\n  this.firstEffect = null;\r\n  this.lastEffect = null;\r\n\r\n  this.expirationTime = NoWork;\r\n  this.childExpirationTime = NoWork;\r\n\r\n  this.alternate = null;\r\n}\r\n```\r\n위와 같이 파이버는 단순한 자바스크립트 객체로 구성되어 있다. \r\n파이버와 리액트 요소의 한가지 중요한 차이점은 `리액트 요소`는 렌더링이 발생할 때 마다 새롭게 생성되지만, `파이버`는 컴포넌트가 최초로 마운트 되는 시점에 생성되어 **가급적이면 재사용된다**는 것이다.\r\n\r\n```js\r\nfunction createFiber(tag, pendingProps, key, mode) {\r\n  return new FiberNode(tag, pendingProps, key, mode);\r\n}\r\n```\r\n```js\r\nfunction createFiberFromElement(element, mode, expirationTime) {\r\n  let owner = null;\r\n  const type = element.type;\r\n  const key = element.key;\r\n  const pendingProps = element.props;\r\n  const fiber = createFiberFromTypeAndProps(\r\n    type,\r\n    key,\r\n    pendingProps,\r\n    owner,\r\n    mode,\r\n    expirationTime,\r\n  );\r\n\r\n  return fiber;\r\n}\r\n```\r\n이제 여기서 선언된 주요 속성을 살펴보면서 어떤 내용을 담고 있는지 살펴보자.\r\n\r\n-   `tag`  : 파이버는 하나의 element에 하나의 파이버가 생성되어 1:1 관계를 가진다. 여기서 **1:1로 매칭된 정보를 가지고 있는 것**이 tag필드이다. 연결되는 것은 컴포넌트, DOM노드 등이 될 수 있는데, 될 수 있는 것들은 다음과 같다.\r\n-  `stateNode`: 이 속성은 파이버 자체에 대한 참조 정보를 가지고 있다.\r\n-  `child`,  `sibling`,  `return`  : 파이버 간의 관계 개념을 나타내는 속성이다. 파이버는 트리 형식을 구성하는데 이 트리 형식을 구성하는데 필요한 정보가 이 속성 내부에 적용된다. 한 가지 리액트 컴포넌트 트리와 다른 점은 children이 없다는 것 즉 **단 하나**의 `child`만이 존재한다는 것이다.\r\n\r\n\t여러 개의 자식이 존재할 경우 항상 **첫 번째 자식의 참조**로 구성되며, 나머지는 자식들은 동등한 `sibling`으로 구성, `return`은 부모 파이버를 의미한다.\r\n\r\n-  `index` : 여러 형제들 사이에서 자신의 위치를 나타낸다.\r\n- `pedingProps`  : 아직 처리하지 못한 props\r\n-   `memoizedProps`  : pendingProps를 기준으로 렌더링이 완료된 이후에 pendingProps를 memoizedProps에 저장하여 관리한다.\r\n-  `updateQueue`  : 상태 업데이트, 콜백 함수, DOM 업데이트 등 작업을 담아두는 Queue.\r\n- `memoizedState`  : 함수 컴포넌트의 훅 목록이 저장된다.\r\n-  `alternate`: 뒤이어 설명할 리액트 파이버 트리와 이어질 개념. 리액트의 트리는 두 개인데, alternate는 반대 트리의 파이버를 가리킨다.\r\n\r\n이렇게 생성된 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다. \r\n이러한 작업들은 작은 단위로 나눠서 처리할 수도, 애니메이션과 같이 우선순위가 높은 작업은 빨리 처리하거나, 낮은 작업을 연기시키는 등 좀 더 유연하게 처리된다.\r\n\r\n\r\n리액트 개발 팀은 사실 리액트는 가상 DOM이 아닌 Value UI, 즉 값을 가지고 있는 UI를 관리하는 라이브러리라는 내용을 피력한 바가 있다. \r\n\r\n즉, 리액트의 핵심원칙은 **UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것**이다. \r\n변수에 이러한 UI관련 값을 보관하고, 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고, 표현하는 것이 바로 리액트다.\r\n\r\n"},{"slug":"posts/Algorithm/[백준 gold 5] 빌런 호석","title":"[백준 gold 5] 빌런 호석","date":"2024-08-09T17:05:24.000Z","image":"index.png","summary":"dfs을 활용한 프로그래머스 [level 3] 징검다리 건너기 문제 풀이 입니다.","tags":["Algorithm","백준","gold","dfs"],"content":"# [gold 3] 빌런 호석\r\n\r\n## 문제 설명\r\n\r\n치르보기 빌딩은 11층부터 NN층까지 이용이 가능한 엘리베이터가 있다. 엘리베이터의 층수를 보여주는 디스플레이에는 KK  자리의 수가 보인다. 수는 00으로 시작할 수도 있다. 00부터 99까지의 각 숫자가 디스플레이에 보이는 방식은 아래와 같다. 각 숫자는 7개의 표시등 중의 일부에 불이 들어오면서 표현된다.\r\n\r\n![](1.png)\r\n\r\n예를 들어 K=4K=4인 경우에 16801680층과 501501층은 아래와 같이 보인다.\r\n\r\n![](2.png)\r\n\r\n\r\n\r\n빌런 호석은 치르보기 빌딩의 엘리베이터 디스플레이의 LED 중에서 최소 11개, 최대 PP개를 반전시킬 계획을 세우고 있다. 반전이란 켜진 부분은 끄고, 꺼진 부분은 켜는 것을 의미한다. 예를 들어 숫자 11을 22로 바꾸려면 총 5개의 LED를 반전시켜야 한다. 또한 반전 이후에 디스플레이에 올바른 수가 보여지면서 11  이상 NN  이하가 되도록 바꿔서 사람들을 헷갈리게 할 예정이다. 치르보기를 사랑하는 모임의 회원인 당신은 호석 빌런의 행동을 미리 파악해서 혼쭐을 내주고자 한다. 현재 엘리베이터가 실제로는 XX층에 멈춰있을 때, 호석이가 반전시킬 LED를 고를 수 있는 경우의 수를 계산해보자.\r\n\r\n### 입력\r\n\r\n N,K,P,XN,K,P,X  가 공백으로 구분되어 첫째 줄에 주어진다.\r\n\r\n### 출력\r\n\r\n호석 빌런이 엘리베이터 LED를 올바르게 반전시킬 수 있는 경우의 수를 계산해보자.\r\n\r\n## 접근 방법\r\n\r\n숫자에 따른 LED를 먼저 구현하기 위해, \r\n\r\n그림과 같이, 각 LED의 위치에 번호를 매겨, 배열안에 그 번호가 있으면 불이 켜져있는 것으로, 없다면 불이 꺼져 있는 것으로 표현하였다.\r\n\u003cimg src=\"3.png\" alt=\"이미지 설명\" width=\"200\" height=\"300\" /\u003e\r\n\r\n\r\n그림처럼 0을 표현하면 3번자리를 제외한 모든 번호가 켜져있으므로, `[0,1,2,4,5,6]`으로 표현 할 수 있다.\r\n\r\n각 번호를 이와 같이 바꾸어 numbers 배열에 저장하면, 이와 같다.\r\n```python\r\nnumbers  = [[0,1,2,4,5,6],[2,5],[0,2,3,4,6],[0,2,3,5,6],[1,2,3,5],[0,1,3,5,6],[0,1,3,4,5,6],[0,2,5],[0,1,2,3,4,5,6],[0,1,2,3,5,6]];\r\n```\r\n이후 만일 현재 번호와 비교할 번호의 LED를 비교하기 위해 서로의 차집합을 더해서 두 번호가 서로를 비교했을 때, 가지고 있는 혹은 없는 번호의 개수를 구한다.\r\n```python\r\ncur_count  =  len(list(cur.difference(compare))) +  len(list(compare.difference(cur)));\r\n```\r\n이와 같은 방식으로 반전시킬 LED의 개수를 구하고, dfs를 활용하여 x의 모든 자릿수를 순회하여 p보다 작거나 같게 LED를 반전하면서, n보다 번호가 작거나 같다면 result를 1 증가 시킨다.\r\n\r\n전체코드는 다음과 같다.\r\n```python\r\nimport sys;\r\ninput = sys.stdin.readline;\r\n\r\nn,k,p,x = map(int, input().split());\r\nresult = 0;\r\nnumbers = [[0,1,2,4,5,6],[2,5],[0,2,3,4,6],[0,2,3,5,6],[1,2,3,5],[0,1,3,5,6],[0,1,3,4,5,6],[0,2,5],[0,1,2,3,4,5,6],[0,1,2,3,5,6]];\r\n\r\nx = list(str(x));\r\nif len(x) != k:\r\n\t# k 보다 자릿수 x가 자릿수가 작다면 작은 만큼 앞에 0을 채워주어야 한다.\r\n    for _ in range(k-len(x)):\r\n        x.insert(0,'0');\r\n        \r\ndef dfs(index,count,st):\r\n    global result;\r\n    if count\u003ep:\r\n        return;\r\n    if index == k:\r\n        if 0\u003ccount\u003c=p and 0\u003cint(st)\u003c=n:\r\n            result += 1;\r\n        return;\r\n    cur = set(numbers[int(x[index])]);\r\n    for i in range(len(numbers)):\r\n        compare = set(numbers[i]);\r\n        cur_count = len(list(cur.difference(compare))) + len(list(compare.difference(cur)));\r\n        if count + cur_count \u003c=p:\r\n            dfs(index+1,count + cur_count,st + str(i));\r\ndfs(0,0,'');\r\nprint(result);\r\n```\r\n\r\n## 느낀 점\r\n사실 이 문제와 관련하여 다른 풀이도 많이 찾아보았고, 더욱 시간이 적게 걸리는 풀이도 많았어서 시간 초과는 나지 않았지만 다소 비효율적인 풀이였다는 생각이 들었다.\r\n\r\n또한 제한 사항중 `또한 반전 이후에 디스플레이에 올바른 수가 보여지면서 1 이상 N 이하가 되도록 바꿔서 사람들을 헷갈리게 할 예정이다.`를 못봐서 계속 `0\u003c=int(st)\u003c=n`로 조건을 설정해놓고 헤맸었다.  문제의 조건을 유심히 보는 습관을 들여야 함을 다시한번 느낀다."},{"slug":"posts/Algorithm/[프로그래머스lv3]아이템 줍기","title":"[프로그래머스 level 3] 아이템 줍기","date":"2024-07-12T16:34:24.000Z","image":"index.png","summary":"bfs를 활용한 프로그래머스 [level 3] 아이템 줍기 문제 풀이 입니다.","tags":["Algorithm","프로그래머스","lv3","bfs"],"content":"# [level 3] 아이템 줍기 (BFS/DFS)\r\n## 문제 설명\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0/README.md#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85)\r\n\r\n다음과 같은 다각형 모양 지형에서 캐릭터가 아이템을 줍기 위해 이동하려 합니다.\r\n\r\n![1.png](1.png)\r\n\r\n지형은 각 변이 x축, y축과 평행한 직사각형이 겹쳐진 형태로 표현하며, 캐릭터는 이 다각형의 둘레(굵은 선)를 따라서 이동합니다.\r\n\r\n만약 직사각형을 겹친 후 다음과 같이 중앙에 빈 공간이 생기는 경우, 다각형의 가장 바깥쪽 테두리가 캐릭터의 이동 경로가 됩니다.\r\n\r\n![2.png](2.png)\r\n\r\n단, 서로 다른 두 직사각형의 x축 좌표 또는 y축 좌표가 같은 경우는 없습니다.\r\n\r\n![rect_3.png](3.png)\r\n\r\n즉, 위 그림처럼 서로 다른 두 직사각형이 꼭짓점에서 만나거나, 변이 겹치는 경우 등은 없습니다.\r\n\r\n다음 그림과 같이 지형이 2개 이상으로 분리된 경우도 없습니다.\r\n\r\n![rect_4.png](4.png)\r\n\r\n한 직사각형이 다른 직사각형 안에 완전히 포함되는 경우 또한 없습니다.\r\n\r\n![rect_5.png](5.png)\r\n\r\n지형을 나타내는 직사각형이 담긴 2차원 배열 rectangle, 초기 캐릭터의 위치 characterX, characterY, 아이템의 위치 itemX, itemY가 solution 함수의 매개변수로 주어질 때, 캐릭터가 아이템을 줍기 위해 이동해야 하는 가장 짧은 거리를 return 하도록 solution 함수를 완성해주세요.\r\n\r\n##### 제한사항\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0/README.md#%EC%A0%9C%ED%95%9C%EC%82%AC%ED%95%AD)\r\n\r\n-   rectangle의 세로(행) 길이는 1 이상 4 이하입니다.\r\n-   rectangle의 원소는 각 직사각형의 [좌측 하단 x, 좌측 하단 y, 우측 상단 x, 우측 상단 y] 좌표 형태입니다.\r\n    -   직사각형을 나타내는 모든 좌표값은 1 이상 50 이하인 자연수입니다.\r\n    -   서로 다른 두 직사각형의 x축 좌표, 혹은 y축 좌표가 같은 경우는 없습니다.\r\n    -   문제에 주어진 조건에 맞는 직사각형만 입력으로 주어집니다.\r\n-   charcterX, charcterY는 1 이상 50 이하인 자연수입니다.\r\n    -   지형을 나타내는 다각형 테두리 위의 한 점이 주어집니다.\r\n-   itemX, itemY는 1 이상 50 이하인 자연수입니다.\r\n    -   지형을 나타내는 다각형 테두리 위의 한 점이 주어집니다.\r\n-   캐릭터와 아이템의 처음 위치가 같은 경우는 없습니다.\r\n\r\n----------\r\n\r\n-   전체 배점의 50%는 직사각형이 1개인 경우입니다.  \r\n    \r\n-   전체 배점의 25%는 직사각형이 2개인 경우입니다.  \r\n    \r\n-   전체 배점의 25%는 직사각형이 3개 또는 4개인 경우입니다.  \r\n    \r\n\r\n----------\r\n\r\n##### 입출력 예\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0/README.md#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%98%88)\r\n\r\n\r\n\u003ctable class=\"table\"\u003e\r\n        \u003cthead\u003e\u003ctr\u003e\r\n\u003cth\u003erectangle\u003c/th\u003e\r\n\u003cth\u003echaracterX\u003c/th\u003e\r\n\u003cth\u003echaracterY\u003c/th\u003e\r\n\u003cth\u003eitemX\u003c/th\u003e\r\n\u003cth\u003eitemY\u003c/th\u003e\r\n\u003cth\u003eresult\u003c/th\u003e\r\n\u003c/tr\u003e\r\n\u003c/thead\u003e\r\n        \u003ctbody\u003e\u003ctr\u003e\r\n\u003ctd\u003e[[1,1,7,4],[3,2,5,5],[4,3,6,9],[2,6,8,8]]\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003ctd\u003e7\u003c/td\u003e\r\n\u003ctd\u003e8\u003c/td\u003e\r\n\u003ctd\u003e17\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003ctr\u003e\r\n\u003ctd\u003e[[1,1,8,4],[2,2,4,9],[3,6,9,8],[6,3,7,7]]\u003c/td\u003e\r\n\u003ctd\u003e9\u003c/td\u003e\r\n\u003ctd\u003e7\u003c/td\u003e\r\n\u003ctd\u003e6\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e11\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003ctr\u003e\r\n\u003ctd\u003e[[1,1,5,7]]\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e4\u003c/td\u003e\r\n\u003ctd\u003e7\u003c/td\u003e\r\n\u003ctd\u003e9\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003ctr\u003e\r\n\u003ctd\u003e[[2,1,7,5],[6,4,10,10]]\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e7\u003c/td\u003e\r\n\u003ctd\u003e10\u003c/td\u003e\r\n\u003ctd\u003e15\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003ctr\u003e\r\n\u003ctd\u003e[[2,2,5,5],[1,3,6,4],[3,1,4,6]]\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e4\u003c/td\u003e\r\n\u003ctd\u003e6\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003ctd\u003e10\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003c/tbody\u003e\r\n      \u003c/table\u003e\r\n\r\n##### 입출력 예 설명\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0/README.md#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%98%88-%EC%84%A4%EB%AA%85)\r\n\r\n입출력 예 #1\r\n\r\n![rect_5.png](6.png)\r\n\r\n캐릭터 위치는 (1, 3)이며, 아이템 위치는 (7, 8)입니다. 위 그림과 같이 굵은 선을 따라 이동하는 경로가 가장 짧습니다.\r\n\r\n입출력 예 #2\r\n\r\n![rect_7.png](7.png)\r\n\r\n캐릭터 위치는 (9, 7)이며, 아이템 위치는 (6, 1)입니다. 위 그림과 같이 굵은 선을 따라 이동하는 경로가 가장 짧습니다.\r\n\r\n입출력 예 #3\r\n\r\n[![rect_8.png](8.png)]\r\n\r\n캐릭터 위치는 (1, 1)이며, 아이템 위치는 (4, 7)입니다. 위 그림과 같이 굵은 선을 따라 이동하는 경로가 가장 짧습니다.\r\n\r\n## 구현 방법\r\n### 전체 직사각형들을 합친 것의 바깥쪽 테두리만 돌게하려면 어떻게 하는가?\r\n- rectangle을 순회하면서 범위 중 직사각형 내부는 0으로 테두리는 1로 board값을 갱신한다.\r\n- 이 때, 만일 `다른 직사각형의 내부안에 현재 직사각형의 테두리가 있지 않을 경우`에만 board를 1로 갱신한다. \r\n### 예외 사항\r\n![exception.png](exception.png)\r\n좌표가 인접한 경우 위와 같이 의도하지 않은 경우를 초래할 수도 있다.\r\n\r\n따라서 이를 해결하기 위해 모든 좌표의 값을 **2배**씩 해주어야 한다.\r\n\r\n이를 모두 반영하여 board 테이블을 만들면,\r\n\r\n```python\r\nboard = [[-1 for _ in range(102)] for _ in range(102)];\r\nfor r in rectangle:\r\n\t# map 객체를 통해 모든 좌표값에 2배\r\n\tx1,y1,x2,y2 = map(lambda x: x*2,r);\r\n     for i in range(x1,x2+1):\r\n        for j in range(y1,y2+1):\r\n\t        # 직사각형 내부의 경우 0으로 개신\r\n            if x1\u003ci\u003cx2 and y1\u003cj\u003cy2:\r\n               board[i][j] = 0;\r\n            # 현재 직사각형의 내부가 아니면서 다른 직사각형의 내부 역시 아닐 때\r\n            elif board[i][j] != 0:\r\n               board[i][j] = 1;\r\n```\r\n이제 여기서 `bfs`를 이용하여 캐릭터 위치에서 아이템 위치까지의 최단거리를 구하면 된다.\r\n\r\n## 전체 코드\r\n```python\r\nfrom collections import deque\r\n\r\ndef solution(rectangle, characterX, characterY, itemX, itemY):\r\n\tboard = [[-1 for _ in range(102)] for _ in range(102)];\r\n\tfor r in rectangle:\r\n\t\t# map 객체를 통해 모든 좌표값에 2배\r\n\t\tx1,y1,x2,y2 = map(lambda x: x*2,r);\r\n\t     for i in range(x1,x2+1):\r\n\t        for j in range(y1,y2+1):\r\n\t\t        # 직사각형 내부의 경우 0으로 개신\r\n\t            if x1\u003ci\u003cx2 and y1\u003cj\u003cy2:\r\n\t               board[i][j] = 0;\r\n\t            # 현재 직사각형의 내부가 아니면서 다른 직사각형의 내부 역시 아닐 때\r\n\t            elif board[i][j] != 0:\r\n\t               board[i][j] = 1;\r\n    dir = [(1,0),(0,1),(-1,0),(0,-1)];\r\n\tvisited = [[0 for _ in range(102)] for _ in range(102)];\r\n    queue = deque();\r\n    queue.append((characterX*2,characterY*2));\r\n    visited[characterX*2][characterY*2] = 1;\r\n    while queue:\r\n        x,y = queue.popleft();\r\n        for dx,dy in dir:\r\n            nx,ny = x+dx,y+dy;\r\n            if 0\u003c=nx\u003c102 and 0\u003c=ny\u003c102:\r\n\t            # 직사각형의 테두리이면서 아직 방문하지 않았을 때\r\n                if board[nx][ny] == 1 and visited[nx][ny] == 0:\r\n                    queue.append((nx,ny));\r\n                    # 거리 갱신\r\n                    visited[nx][ny] = visited[x][y] + 1;\r\n    return visited[itemX*2][itemY*2]//2 \r\n```\r\n\r\n## 느낀 점\r\n직사각형의 내부와 테두리를 갱신하는 방법은 어떻게 떠올렸지만, 예외 상항과 그에 대한 해결 방법은 떠올리지는 못했다. 예외 처리에 관한 관점을 조금 더 넓혀나갈 수 있던 문제였다."}]},"__N_SSG":true},"page":"/","query":{},"buildId":"r3TVFGStx9-VzPRjNWTfb","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>