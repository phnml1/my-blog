<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9c2cc9245ec80007.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/9c2cc9245ec80007.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/4633ec6f7ca519e3.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/4633ec6f7ca519e3.css" crossorigin="" data-n-p=""/><link rel="preload" href="/_next/static/css/83110ef01d855e81.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/83110ef01d855e81.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-5b3d08c41a2bb2b6.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-66d32731bdd20e83.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-aa55ffd08992d156.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-e287481ee6e74633.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/135-0e45b9dfc77f7376.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/979-7390dd4fc9e19803.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/tag/%5Btag%5D-472b20abeb548c59.js" defer="" crossorigin=""></script><script src="/_next/static/at4MBMeAknp2EHehu7FL1/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/at4MBMeAknp2EHehu7FL1/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"tags":["Algorithm","백준","gold","dfs","프로그래머스","lv3","bfs","이분탐색","JavaScript","Dummy","all"],"currentTag":"all","posts":[{"slug":"posts/Algorithm/[백준 gold 5] 빌런 호석","title":"[백준 gold 5] 빌런 호석","date":"2024-08-09T17:05:24.000Z","image":"index.png","summary":"dfs을 활용한 프로그래머스 [level 3] 징검다리 건너기 문제 풀이 입니다.","tags":["Algorithm","백준","gold","dfs"],"content":"# [gold 3] 빌런 호석\r\n\r\n## 문제 설명\r\n\r\n치르보기 빌딩은 11층부터 NN층까지 이용이 가능한 엘리베이터가 있다. 엘리베이터의 층수를 보여주는 디스플레이에는 KK  자리의 수가 보인다. 수는 00으로 시작할 수도 있다. 00부터 99까지의 각 숫자가 디스플레이에 보이는 방식은 아래와 같다. 각 숫자는 7개의 표시등 중의 일부에 불이 들어오면서 표현된다.\r\n\r\n![](1.png)\r\n\r\n예를 들어 K=4K=4인 경우에 16801680층과 501501층은 아래와 같이 보인다.\r\n\r\n![](2.png)\r\n\r\n\r\n\r\n빌런 호석은 치르보기 빌딩의 엘리베이터 디스플레이의 LED 중에서 최소 11개, 최대 PP개를 반전시킬 계획을 세우고 있다. 반전이란 켜진 부분은 끄고, 꺼진 부분은 켜는 것을 의미한다. 예를 들어 숫자 11을 22로 바꾸려면 총 5개의 LED를 반전시켜야 한다. 또한 반전 이후에 디스플레이에 올바른 수가 보여지면서 11  이상 NN  이하가 되도록 바꿔서 사람들을 헷갈리게 할 예정이다. 치르보기를 사랑하는 모임의 회원인 당신은 호석 빌런의 행동을 미리 파악해서 혼쭐을 내주고자 한다. 현재 엘리베이터가 실제로는 XX층에 멈춰있을 때, 호석이가 반전시킬 LED를 고를 수 있는 경우의 수를 계산해보자.\r\n\r\n### 입력\r\n\r\n N,K,P,XN,K,P,X  가 공백으로 구분되어 첫째 줄에 주어진다.\r\n\r\n### 출력\r\n\r\n호석 빌런이 엘리베이터 LED를 올바르게 반전시킬 수 있는 경우의 수를 계산해보자.\r\n\r\n## 접근 방법\r\n\r\n숫자에 따른 LED를 먼저 구현하기 위해, \r\n\r\n그림과 같이, 각 LED의 위치에 번호를 매겨, 배열안에 그 번호가 있으면 불이 켜져있는 것으로, 없다면 불이 꺼져 있는 것으로 표현하였다.\r\n\u003cimg src=\"3.png\" alt=\"이미지 설명\" width=\"200\" height=\"300\" /\u003e\r\n\r\n\r\n그림처럼 0을 표현하면 3번자리를 제외한 모든 번호가 켜져있으므로, `[0,1,2,4,5,6]`으로 표현 할 수 있다.\r\n\r\n각 번호를 이와 같이 바꾸어 numbers 배열에 저장하면, 이와 같다.\r\n```python\r\nnumbers  = [[0,1,2,4,5,6],[2,5],[0,2,3,4,6],[0,2,3,5,6],[1,2,3,5],[0,1,3,5,6],[0,1,3,4,5,6],[0,2,5],[0,1,2,3,4,5,6],[0,1,2,3,5,6]];\r\n```\r\n이후 만일 현재 번호와 비교할 번호의 LED를 비교하기 위해 서로의 차집합을 더해서 두 번호가 서로를 비교했을 때, 가지고 있는 혹은 없는 번호의 개수를 구한다.\r\n```python\r\ncur_count  =  len(list(cur.difference(compare))) +  len(list(compare.difference(cur)));\r\n```\r\n이와 같은 방식으로 반전시킬 LED의 개수를 구하고, dfs를 활용하여 x의 모든 자릿수를 순회하여 p보다 작거나 같게 LED를 반전하면서, n보다 번호가 작거나 같다면 result를 1 증가 시킨다.\r\n\r\n전체코드는 다음과 같다.\r\n```python\r\nimport sys;\r\ninput = sys.stdin.readline;\r\n\r\nn,k,p,x = map(int, input().split());\r\nresult = 0;\r\nnumbers = [[0,1,2,4,5,6],[2,5],[0,2,3,4,6],[0,2,3,5,6],[1,2,3,5],[0,1,3,5,6],[0,1,3,4,5,6],[0,2,5],[0,1,2,3,4,5,6],[0,1,2,3,5,6]];\r\n\r\nx = list(str(x));\r\nif len(x) != k:\r\n\t# k 보다 자릿수 x가 자릿수가 작다면 작은 만큼 앞에 0을 채워주어야 한다.\r\n    for _ in range(k-len(x)):\r\n        x.insert(0,'0');\r\n        \r\ndef dfs(index,count,st):\r\n    global result;\r\n    if count\u003ep:\r\n        return;\r\n    if index == k:\r\n        if 0\u003ccount\u003c=p and 0\u003cint(st)\u003c=n:\r\n            result += 1;\r\n        return;\r\n    cur = set(numbers[int(x[index])]);\r\n    for i in range(len(numbers)):\r\n        compare = set(numbers[i]);\r\n        cur_count = len(list(cur.difference(compare))) + len(list(compare.difference(cur)));\r\n        if count + cur_count \u003c=p:\r\n            dfs(index+1,count + cur_count,st + str(i));\r\ndfs(0,0,'');\r\nprint(result);\r\n```\r\n\r\n## 느낀 점\r\n사실 이 문제와 관련하여 다른 풀이도 많이 찾아보았고, 더욱 시간이 적게 걸리는 풀이도 많았어서 시간 초과는 나지 않았지만 다소 비효율적인 풀이였다는 생각이 들었다.\r\n\r\n또한 제한 사항중 `또한 반전 이후에 디스플레이에 올바른 수가 보여지면서 1 이상 N 이하가 되도록 바꿔서 사람들을 헷갈리게 할 예정이다.`를 못봐서 계속 `0\u003c=int(st)\u003c=n`로 조건을 설정해놓고 헤맸었다.  문제의 조건을 유심히 보는 습관을 들여야 함을 다시한번 느낀다."},{"slug":"posts/Algorithm/[프로그래머스lv3]아이템 줍기","title":"[프로그래머스 level 3] 아이템 줍기","date":"2024-07-12T16:34:24.000Z","image":"index.png","summary":"bfs를 활용한 프로그래머스 [level 3] 아이템 줍기 문제 풀이 입니다.","tags":["Algorithm","프로그래머스","lv3","bfs"],"content":"# [level 3] 아이템 줍기 (BFS/DFS)\r\n## 문제 설명\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0/README.md#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85)\r\n\r\n다음과 같은 다각형 모양 지형에서 캐릭터가 아이템을 줍기 위해 이동하려 합니다.\r\n\r\n![1.png](1.png)\r\n\r\n지형은 각 변이 x축, y축과 평행한 직사각형이 겹쳐진 형태로 표현하며, 캐릭터는 이 다각형의 둘레(굵은 선)를 따라서 이동합니다.\r\n\r\n만약 직사각형을 겹친 후 다음과 같이 중앙에 빈 공간이 생기는 경우, 다각형의 가장 바깥쪽 테두리가 캐릭터의 이동 경로가 됩니다.\r\n\r\n![2.png](2.png)\r\n\r\n단, 서로 다른 두 직사각형의 x축 좌표 또는 y축 좌표가 같은 경우는 없습니다.\r\n\r\n![rect_3.png](3.png)\r\n\r\n즉, 위 그림처럼 서로 다른 두 직사각형이 꼭짓점에서 만나거나, 변이 겹치는 경우 등은 없습니다.\r\n\r\n다음 그림과 같이 지형이 2개 이상으로 분리된 경우도 없습니다.\r\n\r\n![rect_4.png](4.png)\r\n\r\n한 직사각형이 다른 직사각형 안에 완전히 포함되는 경우 또한 없습니다.\r\n\r\n![rect_5.png](5.png)\r\n\r\n지형을 나타내는 직사각형이 담긴 2차원 배열 rectangle, 초기 캐릭터의 위치 characterX, characterY, 아이템의 위치 itemX, itemY가 solution 함수의 매개변수로 주어질 때, 캐릭터가 아이템을 줍기 위해 이동해야 하는 가장 짧은 거리를 return 하도록 solution 함수를 완성해주세요.\r\n\r\n##### 제한사항\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0/README.md#%EC%A0%9C%ED%95%9C%EC%82%AC%ED%95%AD)\r\n\r\n-   rectangle의 세로(행) 길이는 1 이상 4 이하입니다.\r\n-   rectangle의 원소는 각 직사각형의 [좌측 하단 x, 좌측 하단 y, 우측 상단 x, 우측 상단 y] 좌표 형태입니다.\r\n    -   직사각형을 나타내는 모든 좌표값은 1 이상 50 이하인 자연수입니다.\r\n    -   서로 다른 두 직사각형의 x축 좌표, 혹은 y축 좌표가 같은 경우는 없습니다.\r\n    -   문제에 주어진 조건에 맞는 직사각형만 입력으로 주어집니다.\r\n-   charcterX, charcterY는 1 이상 50 이하인 자연수입니다.\r\n    -   지형을 나타내는 다각형 테두리 위의 한 점이 주어집니다.\r\n-   itemX, itemY는 1 이상 50 이하인 자연수입니다.\r\n    -   지형을 나타내는 다각형 테두리 위의 한 점이 주어집니다.\r\n-   캐릭터와 아이템의 처음 위치가 같은 경우는 없습니다.\r\n\r\n----------\r\n\r\n-   전체 배점의 50%는 직사각형이 1개인 경우입니다.  \r\n    \r\n-   전체 배점의 25%는 직사각형이 2개인 경우입니다.  \r\n    \r\n-   전체 배점의 25%는 직사각형이 3개 또는 4개인 경우입니다.  \r\n    \r\n\r\n----------\r\n\r\n##### 입출력 예\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0/README.md#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%98%88)\r\n\r\n\r\n\u003ctable class=\"table\"\u003e\r\n        \u003cthead\u003e\u003ctr\u003e\r\n\u003cth\u003erectangle\u003c/th\u003e\r\n\u003cth\u003echaracterX\u003c/th\u003e\r\n\u003cth\u003echaracterY\u003c/th\u003e\r\n\u003cth\u003eitemX\u003c/th\u003e\r\n\u003cth\u003eitemY\u003c/th\u003e\r\n\u003cth\u003eresult\u003c/th\u003e\r\n\u003c/tr\u003e\r\n\u003c/thead\u003e\r\n        \u003ctbody\u003e\u003ctr\u003e\r\n\u003ctd\u003e[[1,1,7,4],[3,2,5,5],[4,3,6,9],[2,6,8,8]]\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003ctd\u003e7\u003c/td\u003e\r\n\u003ctd\u003e8\u003c/td\u003e\r\n\u003ctd\u003e17\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003ctr\u003e\r\n\u003ctd\u003e[[1,1,8,4],[2,2,4,9],[3,6,9,8],[6,3,7,7]]\u003c/td\u003e\r\n\u003ctd\u003e9\u003c/td\u003e\r\n\u003ctd\u003e7\u003c/td\u003e\r\n\u003ctd\u003e6\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e11\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003ctr\u003e\r\n\u003ctd\u003e[[1,1,5,7]]\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e4\u003c/td\u003e\r\n\u003ctd\u003e7\u003c/td\u003e\r\n\u003ctd\u003e9\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003ctr\u003e\r\n\u003ctd\u003e[[2,1,7,5],[6,4,10,10]]\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e7\u003c/td\u003e\r\n\u003ctd\u003e10\u003c/td\u003e\r\n\u003ctd\u003e15\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003ctr\u003e\r\n\u003ctd\u003e[[2,2,5,5],[1,3,6,4],[3,1,4,6]]\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e4\u003c/td\u003e\r\n\u003ctd\u003e6\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003ctd\u003e10\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003c/tbody\u003e\r\n      \u003c/table\u003e\r\n\r\n##### 입출력 예 설명\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0/README.md#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%98%88-%EC%84%A4%EB%AA%85)\r\n\r\n입출력 예 #1\r\n\r\n![rect_5.png](6.png)\r\n\r\n캐릭터 위치는 (1, 3)이며, 아이템 위치는 (7, 8)입니다. 위 그림과 같이 굵은 선을 따라 이동하는 경로가 가장 짧습니다.\r\n\r\n입출력 예 #2\r\n\r\n![rect_7.png](7.png)\r\n\r\n캐릭터 위치는 (9, 7)이며, 아이템 위치는 (6, 1)입니다. 위 그림과 같이 굵은 선을 따라 이동하는 경로가 가장 짧습니다.\r\n\r\n입출력 예 #3\r\n\r\n[![rect_8.png](8.png)]\r\n\r\n캐릭터 위치는 (1, 1)이며, 아이템 위치는 (4, 7)입니다. 위 그림과 같이 굵은 선을 따라 이동하는 경로가 가장 짧습니다.\r\n\r\n## 구현 방법\r\n### 전체 직사각형들을 합친 것의 바깥쪽 테두리만 돌게하려면 어떻게 하는가?\r\n- rectangle을 순회하면서 범위 중 직사각형 내부는 0으로 테두리는 1로 board값을 갱신한다.\r\n- 이 때, 만일 `다른 직사각형의 내부안에 현재 직사각형의 테두리가 있지 않을 경우`에만 board를 1로 갱신한다. \r\n### 예외 사항\r\n![exception.png](exception.png)\r\n좌표가 인접한 경우 위와 같이 의도하지 않은 경우를 초래할 수도 있다.\r\n\r\n따라서 이를 해결하기 위해 모든 좌표의 값을 **2배**씩 해주어야 한다.\r\n\r\n이를 모두 반영하여 board 테이블을 만들면,\r\n\r\n```python\r\nboard = [[-1 for _ in range(102)] for _ in range(102)];\r\nfor r in rectangle:\r\n\t# map 객체를 통해 모든 좌표값에 2배\r\n\tx1,y1,x2,y2 = map(lambda x: x*2,r);\r\n     for i in range(x1,x2+1):\r\n        for j in range(y1,y2+1):\r\n\t        # 직사각형 내부의 경우 0으로 개신\r\n            if x1\u003ci\u003cx2 and y1\u003cj\u003cy2:\r\n               board[i][j] = 0;\r\n            # 현재 직사각형의 내부가 아니면서 다른 직사각형의 내부 역시 아닐 때\r\n            elif board[i][j] != 0:\r\n               board[i][j] = 1;\r\n```\r\n이제 여기서 `bfs`를 이용하여 캐릭터 위치에서 아이템 위치까지의 최단거리를 구하면 된다.\r\n\r\n## 전체 코드\r\n```python\r\nfrom collections import deque\r\n\r\ndef solution(rectangle, characterX, characterY, itemX, itemY):\r\n\tboard = [[-1 for _ in range(102)] for _ in range(102)];\r\n\tfor r in rectangle:\r\n\t\t# map 객체를 통해 모든 좌표값에 2배\r\n\t\tx1,y1,x2,y2 = map(lambda x: x*2,r);\r\n\t     for i in range(x1,x2+1):\r\n\t        for j in range(y1,y2+1):\r\n\t\t        # 직사각형 내부의 경우 0으로 개신\r\n\t            if x1\u003ci\u003cx2 and y1\u003cj\u003cy2:\r\n\t               board[i][j] = 0;\r\n\t            # 현재 직사각형의 내부가 아니면서 다른 직사각형의 내부 역시 아닐 때\r\n\t            elif board[i][j] != 0:\r\n\t               board[i][j] = 1;\r\n    dir = [(1,0),(0,1),(-1,0),(0,-1)];\r\n\tvisited = [[0 for _ in range(102)] for _ in range(102)];\r\n    queue = deque();\r\n    queue.append((characterX*2,characterY*2));\r\n    visited[characterX*2][characterY*2] = 1;\r\n    while queue:\r\n        x,y = queue.popleft();\r\n        for dx,dy in dir:\r\n            nx,ny = x+dx,y+dy;\r\n            if 0\u003c=nx\u003c102 and 0\u003c=ny\u003c102:\r\n\t            # 직사각형의 테두리이면서 아직 방문하지 않았을 때\r\n                if board[nx][ny] == 1 and visited[nx][ny] == 0:\r\n                    queue.append((nx,ny));\r\n                    # 거리 갱신\r\n                    visited[nx][ny] = visited[x][y] + 1;\r\n    return visited[itemX*2][itemY*2]//2 \r\n```\r\n\r\n## 느낀 점\r\n직사각형의 내부와 테두리를 갱신하는 방법은 어떻게 떠올렸지만, 예외 상항과 그에 대한 해결 방법은 떠올리지는 못했다. 예외 처리에 관한 관점을 조금 더 넓혀나갈 수 있던 문제였다."},{"slug":"posts/Algorithm/[프로그래머스lv3]징검다리건너기","title":"[프로그래머스 level 3] 징검다리 건너기","date":"2024-07-08T18:33:24.000Z","image":"index.png","summary":"이분탐색을 활용한 프로그래머스 [level 3] 징검다리 건너기 문제 풀이 입니다.","tags":["Algorithm","프로그래머스","lv3","이분탐색"],"content":"# [level 3] 징검다리 건너기 - 64062\r\n\r\n## 문제 설명\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/64062.%E2%80%85%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%E2%80%85%EA%B1%B4%EB%84%88%EA%B8%B0/README.md#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85)\r\n\r\n**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**\r\n\r\n카카오 초등학교의 \"니니즈 친구들\"이 \"라이언\" 선생님과 함께 가을 소풍을 가는 중에  **징검다리**가 있는 개울을 만나서 건너편으로 건너려고 합니다. \"라이언\" 선생님은 \"니니즈 친구들\"이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.\r\n\r\n-   징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.\r\n-   디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.\r\n-   단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.\r\n\r\n\"니니즈 친구들\"은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.  \r\n\"니니즈 친구들\"은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.\r\n\r\n디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.\r\n\r\n#### [제한사항]\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/64062.%E2%80%85%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%E2%80%85%EA%B1%B4%EB%84%88%EA%B8%B0/README.md#%EC%A0%9C%ED%95%9C%EC%82%AC%ED%95%AD)\r\n\r\n-   징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.\r\n-   stones 배열의 크기는 1 이상 200,000 이하입니다.\r\n-   stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.\r\n-   k는 1 이상 stones의 길이 이하인 자연수입니다.\r\n\r\n----------\r\n\r\n#### [입출력 예]\r\n\r\n\r\n\u003ctable class=\"table\"\u003e\r\n        \u003cthead\u003e\u003ctr\u003e\r\n\u003cth\u003estones\u003c/th\u003e\r\n\u003cth\u003ek\u003c/th\u003e\r\n\u003cth\u003eresult\u003c/th\u003e\r\n\u003c/tr\u003e\r\n\u003c/thead\u003e\r\n        \u003ctbody\u003e\u003ctr\u003e\r\n\u003ctd\u003e[2, 4, 5, 3, 2, 1, 4, 2, 5, 1]\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003c/tbody\u003e\r\n      \u003c/table\u003e\r\n\r\n##### **입출력 예에 대한 설명**\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/64062.%E2%80%85%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%E2%80%85%EA%B1%B4%EB%84%88%EA%B8%B0/README.md#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%98%88%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%A4%EB%AA%85)\r\n\r\n----------\r\n\r\n**입출력 예 #1**\r\n\r\n첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다.  \r\n![1.png](1.png)\r\n\r\n첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  \r\n두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.  \r\n![2.png](2.png)\r\n\r\n두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  \r\n세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.  \r\n![3.png](3.png)\r\n\r\n세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  \r\n네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 하지만 k = 3 이므로 건너뛸 수 없습니다.  \r\n![4.png](4.png)\r\n\r\n따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.\r\n\r\n## 접근 방법\r\n브루트 포스로 1명씩 건너기에는, stones 배열의 크기가 최대 200,000이고,  stones 배열의 각 원소들의 값 역시 최대 200,000,000이기 때문에, 시간 초과가 날 확률이 높다고 생각했고(사실 그렇게 쉬우면 lv3 일리가 없지), 아니나 다를까 시간초과가 났다. \r\n\r\n고민하다가 도저히 해결책이 안나와서 찾아보니 `이분탐색`을 사용하여 풀 수 있었다.\r\n\r\n- 건널 수 있는 인원의 최소는 1명, 최대는 max(stones)명이다. 모든 돌들의 합이 같거나, 다르다 하더라도 건널수 없는 곳이 k이하면 건널 수 있기 때문이다.  \r\n- 따라서 start = 1 end = max(stones)로 이분탐색을 시작할 수 있다.\r\n\r\nmid 값만큼의 사람이 건널 수 있는지 확인하기 위한 check함수는 다음과 같다.\r\n```python\r\ndef check(stones, mid,k):\r\n    cnt = 0;\r\n    for stone in stones:\r\n\t    # 밟을 수 없으므로 건너뛰어야하는 횟수를 늘린다.\r\n        if (stone - mid) \u003c= 0:\r\n            cnt += 1;\r\n        # 밟을 수 있으므로 최대 건너뛰는 횟수를 초기화시킨다.\r\n        else:\r\n            cnt = 0;\r\n        # 건너뛰는 횟수가 k보다 크거나 같으면 안되므로 False 리턴 \r\n        if cnt\u003e=k:\r\n            return False;\r\n    return True;\r\n```\r\n건널 수 있다면 mid보다 큰 범위에서 값을 찾아야하므로 start를 mid+1로 갱신하고, 반대라면, mid보다 작은 범위에서 값을 찾아야하므로 end를 mid-1로 갱신한다.\r\n \r\ncheck 시간 복잡도는 O(N)이고 이분탐색을 했을 때 O(logN)의 시간복잡도가 나오므로,  총 O(NlogN)의 시간 복잡도가 나오므로, 시간초과가 나지 않는다.\r\n\r\n전체 코드는 다음과 같다.\r\n```python\r\ndef check(stones, mid,k):\r\n    cnt = 0;\r\n    for stone in stones:\r\n        if (stone - mid) \u003c= 0:\r\n            cnt += 1;\r\n        else:\r\n            cnt = 0;\r\n        if cnt\u003e=k:\r\n            return False;\r\n    return True;\r\n\r\ndef solution(stones, k):\r\n    start,end = 1,max(stones);\r\n    answer = 0;\r\n    while start\u003c=end:\r\n        mid = (start + end) // 2;\r\n        if check(stones, mid,k):\r\n            start = mid+1;\r\n        else:\r\n            answer = mid;\r\n            end = mid-1;    \r\n    return answer;\r\n```\r\n\r\n## 느낀 점\r\n이분탐색 문제를 많이는 아니더라도 어느정도는 풀어봤다고 생각했는데, 이 문제에서 이분탐색으로 푸는 아이디어를 떠올리지 못해서 아쉽다. \r\n\r\n또한 처음에 위에 코드의 6번째줄에서 else문을 쓰지않고, 이러한 코드로 제출하여서 시간초과가 났다.\r\n```python\r\nif (stone - mid) \u003c= 0:\r\n\tcnt += 1;\r\nif (stone - mid)\u003e0:\r\n\tcnt = 0;\r\n```\r\nㅎㅎ.. 사실 위와 같은 경우에서 if else문을 쓰는 것이 기본인데, 그래도 시간초과가 날 수 있는 직접적인 원인까지는 되지 않을 거라고 안일하게 생각해서 코드를 짠 게 화근이었다. 기본을 지키자!"},{"slug":"posts/Javascript/javascriptdeepdive10","title":"객체 리터럴","date":"2024-04-29T15:33:24.000Z","image":"javascript.png","summary":"자바스크립트 딥다이브 책 내용 중 '객체 리터럴'의 정리 내용입니다.","tags":["JavaScript"],"content":"\r\n\r\n# 객체 리터럴\r\n\r\n## 객체란?\r\n\r\n\u003e 자바스크립트는 `객체`기반의 프로그래밍 언어이며 자바스크립트를 구성하는 거의 `모든 것`이 객체이다.\r\n\r\n- 원시타입의 값, 원시 값은 변경 불가능 한 값이지만, 객체 타입의 값, 즉 객체는 변경가능한 값이다.\r\n\r\n- 객체는 0개 이상의 `프로퍼티`로 구성된 집합, 프로퍼티는 `키(key): 값(value)`로 구성(**함수도 프로퍼티 값으로 사용 가능!**)\r\n- - 프로퍼티: 객체의 상태를 나타내는 값(data)\r\n\t\r\n  - 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작\r\n\r\n객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 `객체지향 프로그래밍` 이라고 함.\r\n\r\n## 객체리터럴에 의한 객체 생성\r\n```\r\n 인스턴스: 클래스에 의해 생성되어 메모리에 저장된 실체, 객체는 클래스와 인스턴스를 포함한 개념, 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 한다.\r\n ```\r\n자바스크립트는 **프로토타입 객체지향 언어** 로서, 클래스 기반 객체지향 언어와는 달리  다양한 객체 생성방법을 지원한다.\r\n\r\n- 객체 리터럴\r\n- Object 생성자 함수\r\n- 생성자 함수\r\n- Object.create 메서드\r\n- 클래스(ES6)\r\n\r\n객체 리터럴은 **중괄호**(  `{ ... }`  ) 내에 0개 이상의 프로퍼티를 정의한다. **변수에 할당되는 시점**에 자바스크립트 엔진은 **객체 리터럴을 해석**해 객체를 생성한다.\r\n```js\r\nvar person = {\r\n  name: \"Wi\",\r\n  sayHello: function () {\r\n    console.log(`Hello My name is ${this.name}`);\r\n  },\r\n};\r\n\r\nconsole.log(typeof person); // object\r\nconsole.log(person); // { name: 'Wi', sayHello: [Function: sayHello] }\r\n```\r\n중괄호 내에 프로퍼티 정의하지 않으면 **빈 객체** 생성\r\n\r\n## 프로퍼티\r\n**객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.**\r\n```js\r\nvar person = {\r\n  name: \"LEE\", // 프로퍼티 키는 name, 프로퍼티 값은 \"LEE\"\r\n  age: 26, // 프로퍼티 키는 age, 프로퍼티 값은 26\r\n};\r\n```\r\n-   `프로퍼티 키(key)`  : 빈 문자열(  `''`  ) 을 포함하는 모든  `문자열(string)`  또는  `심벌(symbol) 값`\r\n-   `프로퍼티 값(value)`  : 자바스크립트에서 사용할 수 있는 모든 값\r\n\u003cbr/\u003e\r\n\r\n**식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다** (규칙 준수하면 사용안해도 ㄱㅊ)\r\n```js\r\nvar person = {\r\n\tfirstName: 'Joo-young',  // 식별자 네이밍 규칙을 준수한 프로퍼티 키\r\n\t'last-name': 'Lee',       // 식별자 네이밍 규칙을 준수하지 않은 프로퍼티 키 ( 따옴표를 사용해 문자열 형태 유지 )\r\n  last-name: 'Lee'          // SyntaxError: Unexpected token ( 식별자 네이밍 규칙을 준수하지 않은 프로퍼티 키\r\n};\r\nconsole.log(person) // {firstName: 'Joo-young', last-name: 'Lee'}\r\n```\r\n\u003cbr/\u003e\r\n\r\n프로퍼티에 문자열이나 심벌 값 외의 값을 사용하면  **암묵적 타입 변환** 을 통해 문자열이 된다.\r\n```js\r\nvar foo = {\r\n  0: 1,\r\n  1: 2,\r\n  2: 3,\r\n};\r\n\r\nconsole.log(foo); // { 0: 1, 1: 2, 2: 3 } \u003c- 프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지 않지만 내부적으로는 문자열로 변환된다. \r\n```\r\n\u003cbr/\u003e\r\n이미 존재하는 프로퍼티 중복 선언시 나중에 선언한 프로퍼티가 덮어씌워진다. (에러가 발생하지 않는 것 주의하자)\r\n\u003cbr/\u003e\r\n\r\n```js\r\nvar foo = {\r\nname: 'Lee',\r\nname: 'Kim',\r\n}\r\nconsole.log(foo); // {name: 'Kim'}\r\n```\r\n\r\n## 메서드\r\n자바스크립트에서 사용할 수 있는 모든 값은 **프로퍼티 값**으로 사용 가능, 자바스크립트의 함수는 객체(일급 객체) 이다. 따라서 함수는 값으로 취급할 수 있기 때문에 **프로퍼티 값으로 사용할 수 있다.** \r\n\r\n프로퍼티 값이 함수인 경우, 일반 함수와 구분하기 위해, `메서드`라고 부른다. 즉 메서드는 객체에 묶여있는 함수를 의미한다.\r\n\r\n```js\r\nvar circle= {\r\n  // 프로퍼티\r\n  radius: 5,\r\n\r\n  // 메서드\r\n  getDiameter: function () {\r\n    return 2 * this.radius;\r\n  },\r\n};\r\n\r\nconsole.log(person.getDiameter()); // 10\r\n```\r\n## 프로퍼티 접근\r\n- 마침표 프로퍼티 접근 연산자(.)로 사용하는 **마침표 표기법**\r\n- 대괄호 프로퍼티 접근 연산자([...]) 사용하는 **대괄호 표기법**\r\n\r\n\t```js\r\n\tvar person = {\r\n\t\tname: 'Lee'\r\n\t};\r\n\r\n\t// 마침표 표기법에 의한 프로퍼티 접근\r\n\tconsole.log(person.name); // Lee\r\n\r\n\t// 대괄호 표기법에 의한 프로퍼티 접근\r\n\tconsole.log(persone['name']); // Lee\r\n\t```\r\n- 대괄호 표기법을 사용하는 경우 **접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열**이어야 한다.\r\n\u003cbr/\u003e\r\n- 대괄호 프로퍼티 접근 연산자 내에 문자열 형태가 아닌 프로퍼티 키로 사용하면 자바스크립트 엔진은 **식별자로 해석**한다.\r\n-  객체에 존재하지 않는 프로퍼티에 접근하면 **undefined**를 반환한다.\r\n\r\n\t```js\r\n\t// 문자열 형태가 아닌 프로퍼티 키로 사용하면 자바스크립트 엔진은 식별자로 해석함\r\n\tconsole.log(person[name]); // ReferenceError: name is not defined\r\n\t// 객체에 존재하지 않는 프로퍼티에 접근하면 undefined반환\r\n\tconsole.log(person.age); // undefined\r\n\t```\r\n\r\n## 프로퍼티 동적 생성 \u0026 삭제\r\n```js\r\nvar person = {\r\n  name: \"Lee\",\r\n};\r\n// person 객체에 age는 존재x\r\n// 따라서 person객체에 age프로퍼티가 동적으로 생성되고 값이 할당된다.\r\nperson.age = 20; // { age: 20 } \r\nconsole.log(person); // { name: 'Lee', age: 20 }\r\n\r\ndelete person.age; // age 라는 프로퍼티 키가 존재하므로 해당 프로퍼티가 삭제된다.\r\ndelete person.address; // address이라는 프로퍼티 키는 없으므로 삭제 할 수 없지만, 에러는 발생하지 않는다.\r\n\r\nconsole.log(person); // { name: 'Lee' }\r\n```\r\n## ES6에서 추가된 객체 리터럴의 확장 기능\r\n\r\n\r\n### 프로퍼티 축약 표현\r\n```js\r\n// ES5\r\nvar x = 1, y=2;\r\n\r\nvar obj = {\r\n\tx:x,\r\n\ty:y\r\n};\r\nconsole.log(obj); // {x:1, y:2}\r\n\r\n// ES6(프로퍼티 축약 표현)\r\nlet x = 1, y = 2;\r\nconst obj = {x,y};\r\nconsole.log(obj);\r\n```\r\n### 계산된 프로퍼티 이름\r\n`ES5`\r\n```js\r\nvar prefix = \"prop\";\r\nvar i = 0;\r\n\r\nvar obj = {};\r\n\r\n// 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성\r\n// '객체 외부'에서만 가능\r\nobj[prefix + \"-\" + ++i] = i;\r\nobj[prefix + \"-\" + ++i] = i;\r\nobj[prefix + \"-\" + ++i] = i;\r\n\r\nconsole.log(obj); // { prop-1: 1, prop-2: 2, prop-3: 3 }\r\n```\r\n`ES6`\r\n```js\r\nconst prefix = \"prop\";\r\nlet i = 0;\r\n\r\n// '객체 리터럴 내부'에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성\r\nconst obj = {\r\n  [`${prefix}-${++i}`]: i,\r\n  [`${prefix}-${++i}`]: i,\r\n  [`${prefix}-${++i}`]: i,\r\n};\r\n\r\nconsole.log(obj); // { prop-1: 1, prop-2: 2, prop-3: 3 }\r\n```\r\n\r\n### 메서드 축약 표현\r\n`ES5`\r\n```js\r\nvar obj = {\r\n\tname: \"Lee\",\r\n\tsayHi: function () {\r\n\t\tconsole.log('Hi!' + this.name);\r\n\t},\r\n};\r\n\r\nobj.sayHi(); // Hi! Lee\r\n```\r\n`ES6`\r\n```js\r\nconst obj = {\r\n\tname: \"JY\",\r\n\t // 메서드 축약 표현\r\n\tsayHi() {\r\n\t\tconsole.log(`Hi! ${this.name}`);\r\n\t},\r\n};\r\n\r\nobj.sayHi(); // Hi! JY\r\n```\r\n메서드 축약 표현 으로 정의한 메서드는 프로퍼티에 할당한 함수 와 다르게 동작한다.\r\n(이후 자세히 살펴볼 예정)"},{"slug":"posts/Javascript/javascriptdeepdive11","title":"원시 값과 객체의 비교","date":"2024-04-26T14:30:51.000Z","image":"javascript.png","summary":"자바스크립트 딥다이브 책 내용 중 '원시 값과 객체의 비교'의 정리 내용입니다.","tags":["Dummy","JavaScript"],"content":"\r\n# 원시 값과 객체의 비교\r\n\r\n\r\n## 원시 타입 vs 객체 타입\r\n- 원시 타입의 값, 즉 `원시 값`은 **변경 불가능한 값(immutable value)** vs  `객체(참조) 타입의 값`, 즉 객체는 **변경 가능한 값(mutable value)**이다.\r\n- `원시 값`을 변수에 할당하면 변수(확보된 메모리 공간)에는 **실제 값이 저장** vs `객체` 를 변수에 할당하면 변수(확보된 메모리 공간)에는 **참조 값이 저장**\r\n- `원시 값을 갖는 변수`를 다른 변수에 할당하면 원본의 **원시 값이 복사되어 전달**(**값에 의한 전달**)  vs  `객체를 가리키는 변수`를 다른 변수에 할당하면 **원본의 참조 값이 복사되어 전달**(**참조에 의한 전달**)\r\n\r\n## 원시 값\r\n\r\n**원시 값: 원시 타입의 값, 원시 값은 변경 불가능한 값**(`읽기 전용의 값(readonly)`)\r\n\r\n**❗ 변수와 값은 엄연히 다른것!**\r\n- `변수`는 하나의 값을 저장하기 위해 확보한 **메모리 공간 자체** 또는 그 **메모리 공간을 식별하기 위해 붙인 이름**\r\n- `값`은 변수에 저장된 **데이터 표현식이 평가되어 생성된 결과**\r\n- 변경 불가능한 것은 **값에 대한 진술**, 변수는 재할당을 통해, 변수 값을 변경(교체) 가능\r\n\r\n** 변수vs상수 **\r\n+ 변수는 언제든지 `재할당`을 통해 변수 값을 변경(교체)할 수 있다. 그래서 \"변수\"다.\r\n+ 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 `변수`라고 할 수 있다.\r\n+ 하지만, 상수는 단 한 번만 할당이 허용하므로 변수 값을 변경할 수 없다. (이를 변경 불가능한 값으로 동일시하면 안됨 상수는 **재할당이 금지된 변수**)\r\n\r\n###  불변성\r\n변경 불가능한 값인 **원시 값**은 값을 변경하는 것이 아닌, 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 값의 이러한 특성을 `불변성` 이라고 한다.  \r\n\r\n**`불변성` 을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법**이 없다.\r\n\r\n### 문자열과 불변성\r\n자바스크립트는 개발자의 편의를 위해 문자열 타입을 원시 타입으로 제공한다.\r\n\r\n문자열은 유사 배열객체이면서 이터러블이므로 **배열과 유사하게 각 문자에 접근**할 수 있다.\r\n\r\n**유사 배열 객체란?**\r\n\r\n- 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있으며, length 프로퍼티를 갖는 객체\r\n- length 프로퍼티를 갖기 때문에 유사 배열 객체 이며, for 문으로 순회도 할 수 있다.\r\n\t```js\r\n\tvar str = 'string';\r\n\t// 유사배열이므로, 배열과 유사하게 인덱스를 사용해 각 문자로 접근\r\n\tconsole.log(str[0]);\r\n\t// 원시 값인 문자열이 객체처럼 동작\r\n\tconsole.log(str.length); //6\r\n\tconsole.log(str.toUpperCase()); //STRING\r\n\t```\r\n```js\r\nvar str = 'string'\r\n// 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근\r\n// 하지만 문자열은 원시 값이므로 변경할 수 없다. 이때 에러는 발생 x\r\nstr[0] = 'S'\r\nconsole.log(str)// string\r\n```\r\n이는 데이터의 신뢰성을 보장한다. 변수에 새로운 문자열을 재할당하는 것은 물론 가능\r\n\r\n### 값에 의한 전달\r\n```js\r\nvar score = 80;\r\nvar copy = score;\r\n\r\nscore = 100;\r\n\r\nconsole.log(score); // 100 (원본 값)\r\nconsole.log(copy); // 80  (복사한 값)\r\n```\r\nscore는 변수 값 80으로 평가 되므로, copy 변수에도 80이 할당된다. 이때 새로운 숫자 값 80이 생성되어 copy변수에 할당된다\r\n\r\n변수(copy)에는 할당되는 변수(score)의 **원시 값이 복사되어 전달**된다. \r\n 이를,  `값에 의한 전달`이라고 한다.\r\n\r\ncopy와 score는 별개의 값으로써, 서로의 변수의 값에 어떠한 영향도 주지않음.\r\n\r\n또한,\r\n엄격하게 말하자면, 변수에는 값이 전달되는 것이 아니라, **메모리 주소가 전달되는 것이다.**\r\n이는 변수와 같은 식별자는 값이 아니라 **메모리 주소를 기억**하기 때문이다.\r\n\u003e 이처럼 \"값에 의한 전달\"도 사실은 값을 전달하는 것이 아니라, 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.\r\n\r\n하지만 중요한 것은,\r\n\r\n❗ **결국 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.**\r\n\r\n## 객체\r\n\u003e 자바스크립트는 다른 객체지향 언어와는 달리, 클래스 없이 객체 생성가능하며, 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드 추가가 가능하다. V8 엔진에서는 **히든 클래스**라는 방식을 사용한다.\r\n\r\n### 변경 가능한 값\r\n**객체(참조)타입의 값, 즉 객체는 변경 가능한 값**\r\n\r\n원시 값과 다르게, 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조 값**에 접근한다!\r\n- `참조 값`: 생성된 객체가 저장된 메모리 공간의 주소, 그 자체\r\n```js\r\nvar person = {\r\n\tname: 'Lee'\r\n};\r\n\r\n// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근한다.\r\nconsole.log(person) //{name: \"Lee\"}\r\n```\r\n객체를 할당한 변수의 경우 \"변수는 객체를 가리키고(참조하고)있다\" 라고 표현한다.\r\n```person 변수는 {name: 'Lee'}를 가리키고(참조하고) 있다.```\r\n객체를 할당한 변수는 원시 값과 달리,  재할당 없이 객체를 직접 변경할 수 있다.\r\n즉, 재할당 없이  **프로퍼티를 동적으로 추가, 프로퍼티 값을 갱신,  프로퍼티 자체를 삭제도 가능**\r\n\r\n```js\r\nvar person = {\r\n  name: \"Lee\",\r\n};\r\n\r\n// 프로퍼티 값 갱신\r\nperson.name = \"Kim\";\r\n\r\n// 프로퍼티 값 동적 추가\r\nperson.address = \"Seoul\";\r\n\r\nconsole.log(person); // { name: 'Kim', address: 'Seoul' }\r\n```\r\n원시 값과는 다르게 **여러개의 식별자가 하나의 객체를 공유할 수 있다**라는 부작용이 있다.\r\n\r\n### 얕은 복사와 깊은 복사\r\n객체를 프로퍼티의 값으로 갖는 객체의 경우 \r\n- `얕은 복사`는 **한단계만 복사**하는 것을 말하며, 객체의 중첩되어있는 객체의 경우 참조 값을 복사한다.\r\n-  `깊은 복사`는 **객체에 중첩되어 있는 객체까지 모두 복사**하며, **원시 값처럼 완전한 복사본을 만든다.**\r\n\r\n### 참조에 의한 전달\r\n```js\r\nvar person = {\r\n\tname: 'Lee'\r\n};\r\n// 참조 값을 복사(얕은 복사)\r\nvar copy = person;\r\n```\r\nperson을 다른 변수(사본, copy)에 할당하면 **원본의 참조 값이 복사되어 전달**된다. 이를 **참조에 의한 전달** 이라고 한다.\r\n원본 person과 사본 copy는 동일한 참조 값을 가진다. 즉, 둘 모두 동일한 객체를 가리킨다. 이것은 **두 개의 식별자가 하나의 객체를 공유한다는 것을 의미**\r\n```js\r\nvar person = {\r\n  name: \"Lee\",\r\n};\r\n\r\n// \"참조 값\"을 \r\n복사, copy와 person이 동일한 참조 값을 갖는다.\r\nvar copy = person;\r\n// 동일한 객체 참조하므로\r\nconsole.log(copy === person); // true\r\n\r\n// copy를 통해 객체의 name 프로퍼티를 변경한다.\r\ncopy.name = \"Kim\";\r\n\r\n// person을 통해 객체의 address 프로퍼티를 동적 생성한다.\r\nperson.address = \"Seoul\";\r\n\r\n// copy와 person은 동일한 객체를 가리키므로 서로 영향을 주고받음\r\nconsole.log(person); // { name: 'Kim', address: 'Seoul' }\r\nconsole.log(copy); // { name: 'Kim', address: 'Seoul' }\r\n```\r\n\"값에 의한 전달\"과 \"참조에 의한 전달\"은 **식별자가 기억하는 메모리 공간에 저장되어 있는 값을 전달한다는 면에서 동일**하다. 따라서 **\"참조에 의한 전달\"은 존재하지 않고 \"값에 의한 전달\"만이 존재한다고 할 수 있다.**"},{"slug":"posts/Javascript/javascriptdeepdive09","title":"자바스크립트 딥다이브: 09.타입 변환과 단축평가","date":"2024-04-22T12:00:24.000Z","image":"javascript.png","summary":"자바스크립트 딥다이브 책 내용 중 '타입 변환과 단축평가'의 정리 내용입니다.","tags":["JavaScript"],"content":"\r\n# 타입 변환과 단축 평가\r\n개발자가 의도적으로 값의 타입을 변환하는 것: `명시적 타입 변환` or `타입캐스팅`\r\n\r\n개발자의 의도와는 상관없이 표현식을 평가하는 도중에 **자바스크립트 엔진에 의해 암묵적으로 타입이 변환**되는 것: `암묵적 타입 변환` or `타입강제 변환`\r\n\r\n## 암묵적 타입 변환\r\n\u003e 자바스크립트 엔진이 표현식을 평가할 때 개발자의 의도와는 상관없이 `코드의 문맥을 고려해 암묵적으로` 데이터 타입을 강제 변환(암묵적 타입 변환)할 때가 있다.\r\n\r\n암묵적 타입 변환은 문자, 숫자, 불리언 같은 **원시 타입**중 하나로 타입을 자동 변환한다.\r\n\r\n### 문자열 타입으로 변환\r\n```js\r\n// 숫자 타입 \r\n0+'' // '0'\r\nNaN + '' // 'NaN'\r\nInfinity + '' // 'Infinity'\r\n\r\n// 불리언 타입\r\ntrue + '' // 'true'\r\n\r\n// null 타입\r\nnull + '' // 'null'\r\n\r\n// undefined 타입\r\nundefined + '';       // \"undefined\"\r\n\r\n// 심벌 타입\r\n(Symbol()) + '';      // TypeError: Cannot convert a Symbol value to a string\r\n\r\n// 객체 타입\r\n({}) + '';            // \"[object Object]\"\r\nMath + '';            // \"[object Math]\"\r\n[] + '';              // \"\"\r\n[10, 20] + '';        // \"10,20\"\r\n(function(){}_ + '';  // \"function(){}\"\r\nArray + '';           // \"function Array() { [native code] }\"\r\n```\r\n\r\n### 숫자 타입으로 변환\r\n```js\r\n// 문자열 타입(+ 단항연산자는 피연산자가 숫자타입이 아니면 숫자 타입으로 암묵적 타입 변환 수행)\r\n+'' // -\u003e 0\r\n+'0' // 0\r\n+'string' // -\u003e NaN\r\n\r\n// 불리언 타입\r\n+true // -\u003e 1\r\n\r\n// null 타입\r\n+null // -\u003e 0\r\n\r\n//undefined 타입\r\n+undefined // -\u003e NaN\r\n\r\n// 심벌 타입\r\n+Symbol(); // TypeError: Cannot convert a Symbol value to a number\r\n\r\n// 객체 타입\r\n+{}; // -\u003e NaN\r\n+[]; // -\u003e 0\r\n+[10, 20]; // NaN\r\n+function () {}; // NaN\r\n```\r\n**빈 문자열 (''), 빈 배열([]), null, false**는 **0**으로, **true**는 **1**로 변환된다. **객체와 빈 배열이 아닌 배열,undefined**는 변환되지 않아 **NaN**이 된다는 것에 주의하자\r\n\r\n### 불리언 타입으로 변환\r\nif문, for문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참/거짓으로 평가 되어야 하는 표현식이다.\r\n```js\r\n// 모두 코드 블록 실행됨\r\nif(!false) console.log(false + ' is falsy value')\r\nif(!undefined) console.log(undefined + 'is falsy value')\r\nif(!NaN) console.log(NaN + 'is falsy value');\r\nif(!null) console.log(null + 'is falsy value');\r\n```\r\n자바스크립트 엔진은 불리언 타입이 아닌 값을 `Truthy 값(참으로 평가되는 값)` or `Falsy 값(거짓으로 평가되는 값)` 으로 구분한다.\r\n\r\n**자바스크립트 엔진이 Falsy 값으로 판단하는 값**\r\n+ false\r\n+ undefined\r\n+ null\r\n+ 0, -0\r\n+ NaN\r\n+ ''(빈 문자열)\r\n\r\n## 명시적 타입 변환\r\n**개발자의 의도에 따라 명시적으로 타입을 변환하는 것** \r\n\r\n**표준 빌트인 함수(String,Number,Boolean)**을  new연산자 없이 호출하는 방법과 **빌트인 메서드를 사용하는 방법**, 그리고 **암묵적 타입 변환**을 이용하는 방법이 있다.\r\n\r\n### 문자열 타입으로 변환\r\n```js\r\n// String 생성자 함수를 new 연산 없이 호출\r\nString(1); // -\u003e \"1\"\r\nString(NaN); // -\u003e \"NaN\"\r\nString(Infinity); // -\u003e \"Infinity\"\r\nString(false); // -\u003e \"false\"\r\n\r\n// Object.prototype.toString 메서드를 사용하는 방법\r\n(NaN).toString() // -\u003e 'NaN'\r\n(true).toString() // -\u003e 'true'\r\n\r\n// 문자열 연결 연산자\r\nNaN + '' // -\u003e \"NaN\"\r\n```\r\n\r\n### 숫자 타입으로 변환\r\n```js\r\n// Number 생성자 함수를 new 연산자 없이 호출하는 방법\r\nNumber('0') // -\u003e 0\r\nNumber(10.53) // -\u003e 10.53\r\n\r\n// parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)\r\nparseInt('0') // -\u003e 0\r\nparseFloat('10.53') // -\u003e 10.53\r\n\r\n// + 단항 산술 연산자를 이용하는 방법\r\n// 문자열 타입 =\u003e 숫자 타입\r\n+'0'\r\n+'-1'\r\n// 불리언 타입 =\u003e 숫자 타입\r\n+true; //-\u003e1\r\n\r\n// * 산술 연산자를 이용하는 방법\r\n// 문자열 타입 =\u003e 숫자 타입\r\n'0' * 1;\r\n'-1' * 1; //1\r\n// 불리언 타입 =\u003e 숫자 타입\r\ntrue * 1; //-\u003e1\r\n```\r\n\r\n### 불리언 타입으로 변환\r\n```js\r\n// 1. Boolean 생성자 함수를 new 키워드 없이 호출하는 방법\r\nBoolean('x'); // true\r\n\r\nBoolean(0) // false\r\nBoolean(NaN) // false\r\nBoolean(Infinity) // true\r\n\r\nBoolean(null) // false\r\nBoolean(undefined) // false\r\n\r\nBoolean({}) //True\r\n\r\n//2. !(부정 논리 연산자) 두 번 사용\r\n!!'x';  // true ( !(!'x') === !(false) -\u003e true )\r\n```\r\n\r\n## 단축 평가\r\n\u003e `단축 평가` : 논리 연산의 결과를 결정하는 피연산자를 `타입 변환하지 않고 그대로 반환`\r\n-  단축 평가는 표현식을 평가하는 도중에 평가결과가 확정 경우 → 나머지 평가 과정을 생략한다.\r\n단축 평가 표현식\r\n\r\n| 단축 평가 표현식 | 평가 결과 |\r\n|--|--|\r\n|true ll anything  | true |\r\n|false ll anything | anything |\r\n| true \u0026\u0026 anything |  anything|\r\n| false \u0026\u0026 anything | false |\r\n\r\n### 논리 연산자를 단축 평가\r\n`논리곱(\u0026\u0026)` 에서 논리 연산의 결과를 결정하는 것은 **두 번째 피연산자**\r\n```js\r\n'Cat' \u0026\u0026 'Dog'; // Dog\r\n```\r\n\r\n`논리곱(\u0026\u0026) 연산자` 는 두 개의 피연산자가 `모두 true로 평가될 때 true를 반환`, `좌항 -\u003e 우항으로 평가가 진행` \r\n\r\n\r\n`논리합(||)` 에서  논리 연산의 결과를 결정하는 것은 **첫 번째 피연산자**  그러므로 첫 번째 연산자 그대로 반환\r\n```js\r\n'Cat' || 'Dog' // Cat\r\n```\r\n\r\n`논리합 (||) 연산자` 는 `두 개의 피연자 중 하나만 true로 평가되어도 true로 반환`하며, 역시 `좌항에서 우항으로 평가가 진행`\r\n\r\n ```js\r\n // 논리합(||) 연산\r\n\"Cat\" || \"Dog\"; // \"Cat\"\r\nfalse || \"Dog\"; // \"Dog\"\r\n\"Cat\" || false; // \"Cat\"\r\n\r\n// 논리곱(\u0026\u0026) 연산\r\n\"Cat\" \u0026\u0026 \"Dog\"; // \"Dog\"\r\nfalse \u0026\u0026 \"Dog\"; // \"false\"\r\n\"Cat\" \u0026\u0026 false; // \"false\"\r\n ```\r\n **단축평가 사용 예시**\r\n - **if 문대체**\r\n논리 연산자 단축평가를 통해서 if문도 대체할 수 있으며, 값 할당시 보다 더 깔끔할 수 있다.\r\n\t```js\r\n\tvar done = false;\r\n\tvar message = \"\";\r\n\r\n\t// 조건문으로 값 할당\r\n\tif (!done) message = \"미완료\";\r\n\r\n\tmeessage = done || \"미완료\";\r\n\tconsole.log(message) // 미완료\r\n\t```\r\n- **객체를 가리키기를 기대하는 변수의 값이 객체가 아니라 null또는 undefined일 경우** \r\n\r\n\t이러한 경우 타입 에러가 발생한다. 하지만, 단축평가를 사용하면 에러 발생 x\r\n\t```js\r\n\t// elem이 null 또는 undefined같은 Falsy값이면 elem으로 평가\r\n\t// elem이 Truthy값이면 elem.value 값으로 평가\r\n\tvar elem = null;\r\n\tvar value = elem \u0026\u0026 elem.value // null\r\n\t```\r\n- **함수 매개변수에 기본값을 설정**\r\n함수를 호출할 때 인수를 전달하지 않으면 매개변수에는 undefined가 할당된다.  단축평가 사용해 매개변수에 기본값을 설정한다면 에러 방지 가능\r\n\t```js\r\n\t// 단축 평가를 사용한 매개변수의 기본값 설정\r\n\tfunction getStringLength(str) {\r\n\t  str = str || \"\";\r\n\t  return str.length;\r\n\t}\r\n\tgetStringLength(); // 0\r\n\tgetStringLength('hi'); //2\r\n\t//  Es6의 매개변수 default parameter 설정\r\n\tfunction getStringLength(str = \"\") {\r\n\t  return str.length;\r\n\t}\r\n\tgetStringLength(); // 0\r\n\t```\r\n\r\n## 옵셔널 체이닝 연산자\r\n`?` : 좌항의 피 연산자가 null 또는 undefined인 경우 `undefined 반환`, 그렇지않으면 `우항의 포로퍼티 참조`\r\n```js\r\nvar elem = null;\r\nvar value = elem?.value; // undefined\r\n```\r\n-   객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 안전하게 참조할 때 유용\r\n-   옵셔널 체이닝 도입 이전에는  `논리곱(\u0026\u0026)을 사용한 단축 평가`를 통해 변수가 null 또는 undefined 인지 확인했음\r\n```js\r\n// 좌항이 Falsy라면 좌항 그대로 반환(0이나 ''반환 할 때도)\r\nvar str = \"\"; //\r\nvar length = str \u0026\u0026 str.length; // ''\r\n\r\n// 좌항 피연산자가 Falsy값이라도 null 또는 undefined 만 아니면, 우항의 프로퍼티를 참조한다.\r\nvar str = \"\";\r\nvar length = str?.length; // 0\r\n```\r\n\r\n## null 병합 연산자 \r\n`??` : 좌항의 피연산자가 **null또는 undefined인 경우** `우항의 피연산자 반환` 그렇지 않으면 `좌항 피연산자 반환`한다.\r\n```js\r\nvar foo = null ?? \"default string\"; // \"default string\"\r\n```\r\n- 변수에 기본값을 설정할 때 유용하며, 그전에는 논리합(||)을 사용한 단축평가로 변수에 기본값 설정\r\n\t```js\r\n\t// 좌항의 피연산자가 Falsy값이면, 우항의 피연산자를 반환 \r\n\t//(Falsy 값인 0 이나 ''도 기본값으로서 유효하다면 예기치 않은 동작이 발생한다.)\r\n\tvar foo = \"\" || \"default string\"; // \"default string\"\r\n\r\n\t//  좌항의 피연산자가 Falsy값이라도 null 또는 undefined 가 아니면, 좌항의 피연산자를 그대로 반환한다.\r\n\tvar foo = \"\" ?? \"default string\"; // ''\r\n\t```"}]},"__N_SSG":true},"page":"/posts/tag/[tag]","query":{"tag":"all"},"buildId":"at4MBMeAknp2EHehu7FL1","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>