{"pageProps":{"tags":["JavaScript","Dummy","React","Next.js","all"],"currentTag":"JavaScript","posts":[{"slug":"posts/Javascript/javascriptdeepdive10","title":"객체 리터럴","date":"2024-04-29T15:33:24.000Z","image":"javascript.png","summary":"자바스크립트 딥다이브 책 내용 중 '객체 리터럴'의 정리 내용입니다.","tags":["JavaScript"],"content":"\r\n\r\n# 객체 리터럴\r\n\r\n## 객체란?\r\n\r\n> 자바스크립트는 `객체`기반의 프로그래밍 언어이며 자바스크립트를 구성하는 거의 `모든 것`이 객체이다.\r\n\r\n- 원시타입의 값, 원시 값은 변경 불가능 한 값이지만, 객체 타입의 값, 즉 객체는 변경가능한 값이다.\r\n\r\n- 객체는 0개 이상의 `프로퍼티`로 구성된 집합, 프로퍼티는 `키(key): 값(value)`로 구성(**함수도 프로퍼티 값으로 사용 가능!**)\r\n- - 프로퍼티: 객체의 상태를 나타내는 값(data)\r\n\t\r\n  - 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작\r\n\r\n객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 `객체지향 프로그래밍` 이라고 함.\r\n\r\n## 객체리터럴에 의한 객체 생성\r\n```\r\n 인스턴스: 클래스에 의해 생성되어 메모리에 저장된 실체, 객체는 클래스와 인스턴스를 포함한 개념, 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 한다.\r\n ```\r\n자바스크립트는 **프로토타입 객체지향 언어** 로서, 클래스 기반 객체지향 언어와는 달리  다양한 객체 생성방법을 지원한다.\r\n\r\n- 객체 리터럴\r\n- Object 생성자 함수\r\n- 생성자 함수\r\n- Object.create 메서드\r\n- 클래스(ES6)\r\n\r\n객체 리터럴은 **중괄호**(  `{ ... }`  ) 내에 0개 이상의 프로퍼티를 정의한다. **변수에 할당되는 시점**에 자바스크립트 엔진은 **객체 리터럴을 해석**해 객체를 생성한다.\r\n```js\r\nvar person = {\r\n  name: \"Wi\",\r\n  sayHello: function () {\r\n    console.log(`Hello My name is ${this.name}`);\r\n  },\r\n};\r\n\r\nconsole.log(typeof person); // object\r\nconsole.log(person); // { name: 'Wi', sayHello: [Function: sayHello] }\r\n```\r\n중괄호 내에 프로퍼티 정의하지 않으면 **빈 객체** 생성\r\n\r\n## 프로퍼티\r\n**객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.**\r\n```js\r\nvar person = {\r\n  name: \"LEE\", // 프로퍼티 키는 name, 프로퍼티 값은 \"LEE\"\r\n  age: 26, // 프로퍼티 키는 age, 프로퍼티 값은 26\r\n};\r\n```\r\n-   `프로퍼티 키(key)`  : 빈 문자열(  `''`  ) 을 포함하는 모든  `문자열(string)`  또는  `심벌(symbol) 값`\r\n-   `프로퍼티 값(value)`  : 자바스크립트에서 사용할 수 있는 모든 값\r\n<br/>\r\n\r\n**식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다** (규칙 준수하면 사용안해도 ㄱㅊ)\r\n```js\r\nvar person = {\r\n\tfirstName: 'Joo-young',  // 식별자 네이밍 규칙을 준수한 프로퍼티 키\r\n\t'last-name': 'Lee',       // 식별자 네이밍 규칙을 준수하지 않은 프로퍼티 키 ( 따옴표를 사용해 문자열 형태 유지 )\r\n  last-name: 'Lee'          // SyntaxError: Unexpected token ( 식별자 네이밍 규칙을 준수하지 않은 프로퍼티 키\r\n};\r\nconsole.log(person) // {firstName: 'Joo-young', last-name: 'Lee'}\r\n```\r\n<br/>\r\n\r\n프로퍼티에 문자열이나 심벌 값 외의 값을 사용하면  **암묵적 타입 변환** 을 통해 문자열이 된다.\r\n```js\r\nvar foo = {\r\n  0: 1,\r\n  1: 2,\r\n  2: 3,\r\n};\r\n\r\nconsole.log(foo); // { 0: 1, 1: 2, 2: 3 } <- 프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지 않지만 내부적으로는 문자열로 변환된다. \r\n```\r\n<br/>\r\n이미 존재하는 프로퍼티 중복 선언시 나중에 선언한 프로퍼티가 덮어씌워진다. (에러가 발생하지 않는 것 주의하자)\r\n<br/>\r\n\r\n```js\r\nvar foo = {\r\nname: 'Lee',\r\nname: 'Kim',\r\n}\r\nconsole.log(foo); // {name: 'Kim'}\r\n```\r\n\r\n## 메서드\r\n자바스크립트에서 사용할 수 있는 모든 값은 **프로퍼티 값**으로 사용 가능, 자바스크립트의 함수는 객체(일급 객체) 이다. 따라서 함수는 값으로 취급할 수 있기 때문에 **프로퍼티 값으로 사용할 수 있다.** \r\n\r\n프로퍼티 값이 함수인 경우, 일반 함수와 구분하기 위해, `메서드`라고 부른다. 즉 메서드는 객체에 묶여있는 함수를 의미한다.\r\n\r\n```js\r\nvar circle= {\r\n  // 프로퍼티\r\n  radius: 5,\r\n\r\n  // 메서드\r\n  getDiameter: function () {\r\n    return 2 * this.radius;\r\n  },\r\n};\r\n\r\nconsole.log(person.getDiameter()); // 10\r\n```\r\n## 프로퍼티 접근\r\n- 마침표 프로퍼티 접근 연산자(.)로 사용하는 **마침표 표기법**\r\n- 대괄호 프로퍼티 접근 연산자([...]) 사용하는 **대괄호 표기법**\r\n\r\n\t```js\r\n\tvar person = {\r\n\t\tname: 'Lee'\r\n\t};\r\n\r\n\t// 마침표 표기법에 의한 프로퍼티 접근\r\n\tconsole.log(person.name); // Lee\r\n\r\n\t// 대괄호 표기법에 의한 프로퍼티 접근\r\n\tconsole.log(persone['name']); // Lee\r\n\t```\r\n- 대괄호 표기법을 사용하는 경우 **접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열**이어야 한다.\r\n<br/>\r\n- 대괄호 프로퍼티 접근 연산자 내에 문자열 형태가 아닌 프로퍼티 키로 사용하면 자바스크립트 엔진은 **식별자로 해석**한다.\r\n-  객체에 존재하지 않는 프로퍼티에 접근하면 **undefined**를 반환한다.\r\n\r\n\t```js\r\n\t// 문자열 형태가 아닌 프로퍼티 키로 사용하면 자바스크립트 엔진은 식별자로 해석함\r\n\tconsole.log(person[name]); // ReferenceError: name is not defined\r\n\t// 객체에 존재하지 않는 프로퍼티에 접근하면 undefined반환\r\n\tconsole.log(person.age); // undefined\r\n\t```\r\n\r\n## 프로퍼티 동적 생성 & 삭제\r\n```js\r\nvar person = {\r\n  name: \"Lee\",\r\n};\r\n// person 객체에 age는 존재x\r\n// 따라서 person객체에 age프로퍼티가 동적으로 생성되고 값이 할당된다.\r\nperson.age = 20; // { age: 20 } \r\nconsole.log(person); // { name: 'Lee', age: 20 }\r\n\r\ndelete person.age; // age 라는 프로퍼티 키가 존재하므로 해당 프로퍼티가 삭제된다.\r\ndelete person.address; // address이라는 프로퍼티 키는 없으므로 삭제 할 수 없지만, 에러는 발생하지 않는다.\r\n\r\nconsole.log(person); // { name: 'Lee' }\r\n```\r\n## ES6에서 추가된 객체 리터럴의 확장 기능\r\n\r\n\r\n### 프로퍼티 축약 표현\r\n```js\r\n// ES5\r\nvar x = 1, y=2;\r\n\r\nvar obj = {\r\n\tx:x,\r\n\ty:y\r\n};\r\nconsole.log(obj); // {x:1, y:2}\r\n\r\n// ES6(프로퍼티 축약 표현)\r\nlet x = 1, y = 2;\r\nconst obj = {x,y};\r\nconsole.log(obj);\r\n```\r\n### 계산된 프로퍼티 이름\r\n`ES5`\r\n```js\r\nvar prefix = \"prop\";\r\nvar i = 0;\r\n\r\nvar obj = {};\r\n\r\n// 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성\r\n// '객체 외부'에서만 가능\r\nobj[prefix + \"-\" + ++i] = i;\r\nobj[prefix + \"-\" + ++i] = i;\r\nobj[prefix + \"-\" + ++i] = i;\r\n\r\nconsole.log(obj); // { prop-1: 1, prop-2: 2, prop-3: 3 }\r\n```\r\n`ES6`\r\n```js\r\nconst prefix = \"prop\";\r\nlet i = 0;\r\n\r\n// '객체 리터럴 내부'에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성\r\nconst obj = {\r\n  [`${prefix}-${++i}`]: i,\r\n  [`${prefix}-${++i}`]: i,\r\n  [`${prefix}-${++i}`]: i,\r\n};\r\n\r\nconsole.log(obj); // { prop-1: 1, prop-2: 2, prop-3: 3 }\r\n```\r\n\r\n### 메서드 축약 표현\r\n`ES5`\r\n```js\r\nvar obj = {\r\n\tname: \"Lee\",\r\n\tsayHi: function () {\r\n\t\tconsole.log('Hi!' + this.name);\r\n\t},\r\n};\r\n\r\nobj.sayHi(); // Hi! Lee\r\n```\r\n`ES6`\r\n```js\r\nconst obj = {\r\n\tname: \"JY\",\r\n\t // 메서드 축약 표현\r\n\tsayHi() {\r\n\t\tconsole.log(`Hi! ${this.name}`);\r\n\t},\r\n};\r\n\r\nobj.sayHi(); // Hi! JY\r\n```\r\n메서드 축약 표현 으로 정의한 메서드는 프로퍼티에 할당한 함수 와 다르게 동작한다.\r\n(이후 자세히 살펴볼 예정)"},{"slug":"posts/Javascript/javascriptdeepdive11","title":"원시 값과 객체의 비교","date":"2024-04-26T14:30:51.000Z","image":"javascript.png","summary":"자바스크립트 딥다이브 책 내용 중 '원시 값과 객체의 비교'의 정리 내용입니다.","tags":["Dummy","JavaScript"],"content":"\r\n# 원시 값과 객체의 비교\r\n\r\n\r\n## 원시 타입 vs 객체 타입\r\n- 원시 타입의 값, 즉 `원시 값`은 **변경 불가능한 값(immutable value)** vs  `객체(참조) 타입의 값`, 즉 객체는 **변경 가능한 값(mutable value)**이다.\r\n- `원시 값`을 변수에 할당하면 변수(확보된 메모리 공간)에는 **실제 값이 저장** vs `객체` 를 변수에 할당하면 변수(확보된 메모리 공간)에는 **참조 값이 저장**\r\n- `원시 값을 갖는 변수`를 다른 변수에 할당하면 원본의 **원시 값이 복사되어 전달**(**값에 의한 전달**)  vs  `객체를 가리키는 변수`를 다른 변수에 할당하면 **원본의 참조 값이 복사되어 전달**(**참조에 의한 전달**)\r\n\r\n## 원시 값\r\n\r\n**원시 값: 원시 타입의 값, 원시 값은 변경 불가능한 값**(`읽기 전용의 값(readonly)`)\r\n\r\n**❗ 변수와 값은 엄연히 다른것!**\r\n- `변수`는 하나의 값을 저장하기 위해 확보한 **메모리 공간 자체** 또는 그 **메모리 공간을 식별하기 위해 붙인 이름**\r\n- `값`은 변수에 저장된 **데이터 표현식이 평가되어 생성된 결과**\r\n- 변경 불가능한 것은 **값에 대한 진술**, 변수는 재할당을 통해, 변수 값을 변경(교체) 가능\r\n\r\n** 변수vs상수 **\r\n+ 변수는 언제든지 `재할당`을 통해 변수 값을 변경(교체)할 수 있다. 그래서 \"변수\"다.\r\n+ 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 `변수`라고 할 수 있다.\r\n+ 하지만, 상수는 단 한 번만 할당이 허용하므로 변수 값을 변경할 수 없다. (이를 변경 불가능한 값으로 동일시하면 안됨 상수는 **재할당이 금지된 변수**)\r\n\r\n###  불변성\r\n변경 불가능한 값인 **원시 값**은 값을 변경하는 것이 아닌, 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 값의 이러한 특성을 `불변성` 이라고 한다.  \r\n\r\n**`불변성` 을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법**이 없다.\r\n\r\n### 문자열과 불변성\r\n자바스크립트는 개발자의 편의를 위해 문자열 타입을 원시 타입으로 제공한다.\r\n\r\n문자열은 유사 배열객체이면서 이터러블이므로 **배열과 유사하게 각 문자에 접근**할 수 있다.\r\n\r\n**유사 배열 객체란?**\r\n\r\n- 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있으며, length 프로퍼티를 갖는 객체\r\n- length 프로퍼티를 갖기 때문에 유사 배열 객체 이며, for 문으로 순회도 할 수 있다.\r\n\t```js\r\n\tvar str = 'string';\r\n\t// 유사배열이므로, 배열과 유사하게 인덱스를 사용해 각 문자로 접근\r\n\tconsole.log(str[0]);\r\n\t// 원시 값인 문자열이 객체처럼 동작\r\n\tconsole.log(str.length); //6\r\n\tconsole.log(str.toUpperCase()); //STRING\r\n\t```\r\n```js\r\nvar str = 'string'\r\n// 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근\r\n// 하지만 문자열은 원시 값이므로 변경할 수 없다. 이때 에러는 발생 x\r\nstr[0] = 'S'\r\nconsole.log(str)// string\r\n```\r\n이는 데이터의 신뢰성을 보장한다. 변수에 새로운 문자열을 재할당하는 것은 물론 가능\r\n\r\n### 값에 의한 전달\r\n```js\r\nvar score = 80;\r\nvar copy = score;\r\n\r\nscore = 100;\r\n\r\nconsole.log(score); // 100 (원본 값)\r\nconsole.log(copy); // 80  (복사한 값)\r\n```\r\nscore는 변수 값 80으로 평가 되므로, copy 변수에도 80이 할당된다. 이때 새로운 숫자 값 80이 생성되어 copy변수에 할당된다\r\n\r\n변수(copy)에는 할당되는 변수(score)의 **원시 값이 복사되어 전달**된다. \r\n 이를,  `값에 의한 전달`이라고 한다.\r\n\r\ncopy와 score는 별개의 값으로써, 서로의 변수의 값에 어떠한 영향도 주지않음.\r\n\r\n또한,\r\n엄격하게 말하자면, 변수에는 값이 전달되는 것이 아니라, **메모리 주소가 전달되는 것이다.**\r\n이는 변수와 같은 식별자는 값이 아니라 **메모리 주소를 기억**하기 때문이다.\r\n> 이처럼 \"값에 의한 전달\"도 사실은 값을 전달하는 것이 아니라, 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.\r\n\r\n하지만 중요한 것은,\r\n\r\n❗ **결국 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.**\r\n\r\n## 객체\r\n> 자바스크립트는 다른 객체지향 언어와는 달리, 클래스 없이 객체 생성가능하며, 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드 추가가 가능하다. V8 엔진에서는 **히든 클래스**라는 방식을 사용한다.\r\n\r\n### 변경 가능한 값\r\n**객체(참조)타입의 값, 즉 객체는 변경 가능한 값**\r\n\r\n원시 값과 다르게, 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조 값**에 접근한다!\r\n- `참조 값`: 생성된 객체가 저장된 메모리 공간의 주소, 그 자체\r\n```js\r\nvar person = {\r\n\tname: 'Lee'\r\n};\r\n\r\n// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근한다.\r\nconsole.log(person) //{name: \"Lee\"}\r\n```\r\n객체를 할당한 변수의 경우 \"변수는 객체를 가리키고(참조하고)있다\" 라고 표현한다.\r\n```person 변수는 {name: 'Lee'}를 가리키고(참조하고) 있다.```\r\n객체를 할당한 변수는 원시 값과 달리,  재할당 없이 객체를 직접 변경할 수 있다.\r\n즉, 재할당 없이  **프로퍼티를 동적으로 추가, 프로퍼티 값을 갱신,  프로퍼티 자체를 삭제도 가능**\r\n\r\n```js\r\nvar person = {\r\n  name: \"Lee\",\r\n};\r\n\r\n// 프로퍼티 값 갱신\r\nperson.name = \"Kim\";\r\n\r\n// 프로퍼티 값 동적 추가\r\nperson.address = \"Seoul\";\r\n\r\nconsole.log(person); // { name: 'Kim', address: 'Seoul' }\r\n```\r\n원시 값과는 다르게 **여러개의 식별자가 하나의 객체를 공유할 수 있다**라는 부작용이 있다.\r\n\r\n### 얕은 복사와 깊은 복사\r\n객체를 프로퍼티의 값으로 갖는 객체의 경우 \r\n- `얕은 복사`는 **한단계만 복사**하는 것을 말하며, 객체의 중첩되어있는 객체의 경우 참조 값을 복사한다.\r\n-  `깊은 복사`는 **객체에 중첩되어 있는 객체까지 모두 복사**하며, **원시 값처럼 완전한 복사본을 만든다.**\r\n\r\n### 참조에 의한 전달\r\n```js\r\nvar person = {\r\n\tname: 'Lee'\r\n};\r\n// 참조 값을 복사(얕은 복사)\r\nvar copy = person;\r\n```\r\nperson을 다른 변수(사본, copy)에 할당하면 **원본의 참조 값이 복사되어 전달**된다. 이를 **참조에 의한 전달** 이라고 한다.\r\n원본 person과 사본 copy는 동일한 참조 값을 가진다. 즉, 둘 모두 동일한 객체를 가리킨다. 이것은 **두 개의 식별자가 하나의 객체를 공유한다는 것을 의미**\r\n```js\r\nvar person = {\r\n  name: \"Lee\",\r\n};\r\n\r\n// \"참조 값\"을 \r\n복사, copy와 person이 동일한 참조 값을 갖는다.\r\nvar copy = person;\r\n// 동일한 객체 참조하므로\r\nconsole.log(copy === person); // true\r\n\r\n// copy를 통해 객체의 name 프로퍼티를 변경한다.\r\ncopy.name = \"Kim\";\r\n\r\n// person을 통해 객체의 address 프로퍼티를 동적 생성한다.\r\nperson.address = \"Seoul\";\r\n\r\n// copy와 person은 동일한 객체를 가리키므로 서로 영향을 주고받음\r\nconsole.log(person); // { name: 'Kim', address: 'Seoul' }\r\nconsole.log(copy); // { name: 'Kim', address: 'Seoul' }\r\n```\r\n\"값에 의한 전달\"과 \"참조에 의한 전달\"은 **식별자가 기억하는 메모리 공간에 저장되어 있는 값을 전달한다는 면에서 동일**하다. 따라서 **\"참조에 의한 전달\"은 존재하지 않고 \"값에 의한 전달\"만이 존재한다고 할 수 있다.**"},{"slug":"posts/Javascript/javascriptdeepdive09","title":"자바스크립트 딥다이브: 09.타입 변환과 단축평가","date":"2024-04-22T12:00:24.000Z","image":"javascript.png","summary":"자바스크립트 딥다이브 책 내용 중 '타입 변환과 단축평가'의 정리 내용입니다.","tags":["JavaScript"],"content":"\r\n# 타입 변환과 단축 평가\r\n개발자가 의도적으로 값의 타입을 변환하는 것: `명시적 타입 변환` or `타입캐스팅`\r\n\r\n개발자의 의도와는 상관없이 표현식을 평가하는 도중에 **자바스크립트 엔진에 의해 암묵적으로 타입이 변환**되는 것: `암묵적 타입 변환` or `타입강제 변환`\r\n\r\n## 암묵적 타입 변환\r\n> 자바스크립트 엔진이 표현식을 평가할 때 개발자의 의도와는 상관없이 `코드의 문맥을 고려해 암묵적으로` 데이터 타입을 강제 변환(암묵적 타입 변환)할 때가 있다.\r\n\r\n암묵적 타입 변환은 문자, 숫자, 불리언 같은 **원시 타입**중 하나로 타입을 자동 변환한다.\r\n\r\n### 문자열 타입으로 변환\r\n```js\r\n// 숫자 타입 \r\n0+'' // '0'\r\nNaN + '' // 'NaN'\r\nInfinity + '' // 'Infinity'\r\n\r\n// 불리언 타입\r\ntrue + '' // 'true'\r\n\r\n// null 타입\r\nnull + '' // 'null'\r\n\r\n// undefined 타입\r\nundefined + '';       // \"undefined\"\r\n\r\n// 심벌 타입\r\n(Symbol()) + '';      // TypeError: Cannot convert a Symbol value to a string\r\n\r\n// 객체 타입\r\n({}) + '';            // \"[object Object]\"\r\nMath + '';            // \"[object Math]\"\r\n[] + '';              // \"\"\r\n[10, 20] + '';        // \"10,20\"\r\n(function(){}_ + '';  // \"function(){}\"\r\nArray + '';           // \"function Array() { [native code] }\"\r\n```\r\n\r\n### 숫자 타입으로 변환\r\n```js\r\n// 문자열 타입(+ 단항연산자는 피연산자가 숫자타입이 아니면 숫자 타입으로 암묵적 타입 변환 수행)\r\n+'' // -> 0\r\n+'0' // 0\r\n+'string' // -> NaN\r\n\r\n// 불리언 타입\r\n+true // -> 1\r\n\r\n// null 타입\r\n+null // -> 0\r\n\r\n//undefined 타입\r\n+undefined // -> NaN\r\n\r\n// 심벌 타입\r\n+Symbol(); // TypeError: Cannot convert a Symbol value to a number\r\n\r\n// 객체 타입\r\n+{}; // -> NaN\r\n+[]; // -> 0\r\n+[10, 20]; // NaN\r\n+function () {}; // NaN\r\n```\r\n**빈 문자열 (''), 빈 배열([]), null, false**는 **0**으로, **true**는 **1**로 변환된다. **객체와 빈 배열이 아닌 배열,undefined**는 변환되지 않아 **NaN**이 된다는 것에 주의하자\r\n\r\n### 불리언 타입으로 변환\r\nif문, for문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참/거짓으로 평가 되어야 하는 표현식이다.\r\n```js\r\n// 모두 코드 블록 실행됨\r\nif(!false) console.log(false + ' is falsy value')\r\nif(!undefined) console.log(undefined + 'is falsy value')\r\nif(!NaN) console.log(NaN + 'is falsy value');\r\nif(!null) console.log(null + 'is falsy value');\r\n```\r\n자바스크립트 엔진은 불리언 타입이 아닌 값을 `Truthy 값(참으로 평가되는 값)` or `Falsy 값(거짓으로 평가되는 값)` 으로 구분한다.\r\n\r\n**자바스크립트 엔진이 Falsy 값으로 판단하는 값**\r\n+ false\r\n+ undefined\r\n+ null\r\n+ 0, -0\r\n+ NaN\r\n+ ''(빈 문자열)\r\n\r\n## 명시적 타입 변환\r\n**개발자의 의도에 따라 명시적으로 타입을 변환하는 것** \r\n\r\n**표준 빌트인 함수(String,Number,Boolean)**을  new연산자 없이 호출하는 방법과 **빌트인 메서드를 사용하는 방법**, 그리고 **암묵적 타입 변환**을 이용하는 방법이 있다.\r\n\r\n### 문자열 타입으로 변환\r\n```js\r\n// String 생성자 함수를 new 연산 없이 호출\r\nString(1); // -> \"1\"\r\nString(NaN); // -> \"NaN\"\r\nString(Infinity); // -> \"Infinity\"\r\nString(false); // -> \"false\"\r\n\r\n// Object.prototype.toString 메서드를 사용하는 방법\r\n(NaN).toString() // -> 'NaN'\r\n(true).toString() // -> 'true'\r\n\r\n// 문자열 연결 연산자\r\nNaN + '' // -> \"NaN\"\r\n```\r\n\r\n### 숫자 타입으로 변환\r\n```js\r\n// Number 생성자 함수를 new 연산자 없이 호출하는 방법\r\nNumber('0') // -> 0\r\nNumber(10.53) // -> 10.53\r\n\r\n// parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)\r\nparseInt('0') // -> 0\r\nparseFloat('10.53') // -> 10.53\r\n\r\n// + 단항 산술 연산자를 이용하는 방법\r\n// 문자열 타입 => 숫자 타입\r\n+'0'\r\n+'-1'\r\n// 불리언 타입 => 숫자 타입\r\n+true; //->1\r\n\r\n// * 산술 연산자를 이용하는 방법\r\n// 문자열 타입 => 숫자 타입\r\n'0' * 1;\r\n'-1' * 1; //1\r\n// 불리언 타입 => 숫자 타입\r\ntrue * 1; //->1\r\n```\r\n\r\n### 불리언 타입으로 변환\r\n```js\r\n// 1. Boolean 생성자 함수를 new 키워드 없이 호출하는 방법\r\nBoolean('x'); // true\r\n\r\nBoolean(0) // false\r\nBoolean(NaN) // false\r\nBoolean(Infinity) // true\r\n\r\nBoolean(null) // false\r\nBoolean(undefined) // false\r\n\r\nBoolean({}) //True\r\n\r\n//2. !(부정 논리 연산자) 두 번 사용\r\n!!'x';  // true ( !(!'x') === !(false) -> true )\r\n```\r\n\r\n## 단축 평가\r\n> `단축 평가` : 논리 연산의 결과를 결정하는 피연산자를 `타입 변환하지 않고 그대로 반환`\r\n-  단축 평가는 표현식을 평가하는 도중에 평가결과가 확정 경우 → 나머지 평가 과정을 생략한다.\r\n단축 평가 표현식\r\n\r\n| 단축 평가 표현식 | 평가 결과 |\r\n|--|--|\r\n|true ll anything  | true |\r\n|false ll anything | anything |\r\n| true && anything |  anything|\r\n| false && anything | false |\r\n\r\n### 논리 연산자를 단축 평가\r\n`논리곱(&&)` 에서 논리 연산의 결과를 결정하는 것은 **두 번째 피연산자**\r\n```js\r\n'Cat' && 'Dog'; // Dog\r\n```\r\n\r\n`논리곱(&&) 연산자` 는 두 개의 피연산자가 `모두 true로 평가될 때 true를 반환`, `좌항 -> 우항으로 평가가 진행` \r\n\r\n\r\n`논리합(||)` 에서  논리 연산의 결과를 결정하는 것은 **첫 번째 피연산자**  그러므로 첫 번째 연산자 그대로 반환\r\n```js\r\n'Cat' || 'Dog' // Cat\r\n```\r\n\r\n`논리합 (||) 연산자` 는 `두 개의 피연자 중 하나만 true로 평가되어도 true로 반환`하며, 역시 `좌항에서 우항으로 평가가 진행`\r\n\r\n ```js\r\n // 논리합(||) 연산\r\n\"Cat\" || \"Dog\"; // \"Cat\"\r\nfalse || \"Dog\"; // \"Dog\"\r\n\"Cat\" || false; // \"Cat\"\r\n\r\n// 논리곱(&&) 연산\r\n\"Cat\" && \"Dog\"; // \"Dog\"\r\nfalse && \"Dog\"; // \"false\"\r\n\"Cat\" && false; // \"false\"\r\n ```\r\n **단축평가 사용 예시**\r\n - **if 문대체**\r\n논리 연산자 단축평가를 통해서 if문도 대체할 수 있으며, 값 할당시 보다 더 깔끔할 수 있다.\r\n\t```js\r\n\tvar done = false;\r\n\tvar message = \"\";\r\n\r\n\t// 조건문으로 값 할당\r\n\tif (!done) message = \"미완료\";\r\n\r\n\tmeessage = done || \"미완료\";\r\n\tconsole.log(message) // 미완료\r\n\t```\r\n- **객체를 가리키기를 기대하는 변수의 값이 객체가 아니라 null또는 undefined일 경우** \r\n\r\n\t이러한 경우 타입 에러가 발생한다. 하지만, 단축평가를 사용하면 에러 발생 x\r\n\t```js\r\n\t// elem이 null 또는 undefined같은 Falsy값이면 elem으로 평가\r\n\t// elem이 Truthy값이면 elem.value 값으로 평가\r\n\tvar elem = null;\r\n\tvar value = elem && elem.value // null\r\n\t```\r\n- **함수 매개변수에 기본값을 설정**\r\n함수를 호출할 때 인수를 전달하지 않으면 매개변수에는 undefined가 할당된다.  단축평가 사용해 매개변수에 기본값을 설정한다면 에러 방지 가능\r\n\t```js\r\n\t// 단축 평가를 사용한 매개변수의 기본값 설정\r\n\tfunction getStringLength(str) {\r\n\t  str = str || \"\";\r\n\t  return str.length;\r\n\t}\r\n\tgetStringLength(); // 0\r\n\tgetStringLength('hi'); //2\r\n\t//  Es6의 매개변수 default parameter 설정\r\n\tfunction getStringLength(str = \"\") {\r\n\t  return str.length;\r\n\t}\r\n\tgetStringLength(); // 0\r\n\t```\r\n\r\n## 옵셔널 체이닝 연산자\r\n`?` : 좌항의 피 연산자가 null 또는 undefined인 경우 `undefined 반환`, 그렇지않으면 `우항의 포로퍼티 참조`\r\n```js\r\nvar elem = null;\r\nvar value = elem?.value; // undefined\r\n```\r\n-   객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 안전하게 참조할 때 유용\r\n-   옵셔널 체이닝 도입 이전에는  `논리곱(&&)을 사용한 단축 평가`를 통해 변수가 null 또는 undefined 인지 확인했음\r\n```js\r\n// 좌항이 Falsy라면 좌항 그대로 반환(0이나 ''반환 할 때도)\r\nvar str = \"\"; //\r\nvar length = str && str.length; // ''\r\n\r\n// 좌항 피연산자가 Falsy값이라도 null 또는 undefined 만 아니면, 우항의 프로퍼티를 참조한다.\r\nvar str = \"\";\r\nvar length = str?.length; // 0\r\n```\r\n\r\n## null 병합 연산자 \r\n`??` : 좌항의 피연산자가 **null또는 undefined인 경우** `우항의 피연산자 반환` 그렇지 않으면 `좌항 피연산자 반환`한다.\r\n```js\r\nvar foo = null ?? \"default string\"; // \"default string\"\r\n```\r\n- 변수에 기본값을 설정할 때 유용하며, 그전에는 논리합(||)을 사용한 단축평가로 변수에 기본값 설정\r\n\t```js\r\n\t// 좌항의 피연산자가 Falsy값이면, 우항의 피연산자를 반환 \r\n\t//(Falsy 값인 0 이나 ''도 기본값으로서 유효하다면 예기치 않은 동작이 발생한다.)\r\n\tvar foo = \"\" || \"default string\"; // \"default string\"\r\n\r\n\t//  좌항의 피연산자가 Falsy값이라도 null 또는 undefined 가 아니면, 좌항의 피연산자를 그대로 반환한다.\r\n\tvar foo = \"\" ?? \"default string\"; // ''\r\n\t```"},{"slug":"posts/Javascript/getting-started-with-nextjs","title":"Getting Started with NextJS","date":"2023-05-24T23:19:24.000Z","image":"getting-started-nextjs.jpg","summary":"NextJS is a the React framework for production - it makes building fullstack React apps and sites a breeze and ships with built-in SSR.","tags":["Dummy","JavaScript"],"isFeatured":false,"content":"\r\nNextJS is a **framework for ReactJS**.\r\n\r\nWait a second ... a \"framework\" for React? Isn't React itself already a framework for JavaScript?\r\n\r\nWell ... first of all, React is a \"library\" for JavaScript. That seems to be important for some people.\r\n\r\nNot for me, but still, there is a valid point: React already is a framework / library for JavaScript. So it's already an extra layer on top of JS.\r\n\r\n## Why would we then need NextJS?\r\n\r\nBecause NextJS makes building React apps easier - especially React apps that should have server-side rendering (though it does way more than just take care of that).\r\n\r\nIn this article, we'll dive into the core concepts and features NextJS has to offer:\r\n\r\n- File-based Routing\r\n- Built-in Page Pre-rendering\r\n- Rich Data Fetching Capabilities\r\n- Image Optimization\r\n- Much More\r\n\r\n## File-based Routing\r\n\r\n![Create routes via your file + folder structure](nextjs-file-based-routing.png)\r\n\r\n... More content ..."}]},"__N_SSG":true}